(*===============================================================================*)
(*                                                                               *)
(*                rmem executable model                                          *)
(*                =====================                                          *)
(*                                                                               *)
(*  This file is:                                                                *)
(*                                                                               *)
(*  Copyright Christopher Pulte, University of Cambridge 2017-2018               *)
(*  Copyright Shaked Flur, University of Cambridge            2017               *)
(*  Copyright Jon French, University of Cambridge             2018               *)
(*                                                                               *)
(*  All rights reserved.                                                         *)
(*                                                                               *)
(*  It is part of the rmem tool, distributed under the 2-clause BSD licence in   *)
(*  LICENCE.txt.                                                                 *)
(*                                                                               *)
(*===============================================================================*)

open import Relation
open import Pervasives_extra
open import Sail_impl_base
open import InstructionSemantics
open import FreshIds
open import Events
open import Fragments
open import Debug
open import Utils
open import Params
open import BasicTypes
open import RegUtils
open import CandidateExecution
     import Map
open ListMonad
open import PromisingViews
open import PromisingTransitions
open import PromisingThread
open import PromisingStorage



type p_state 'ts 'ss 'v =
  <| p_program_memory:        (address -> fetch_and_decode_outcome);
     p_initial_writes:        list write;
     p_thread_states:         map thread_id 'ts;
     p_storage_state:         'ss;
     p_model:                 model_params;
     p_instruction_semantics: instruction_semantics;
     p_stopped_promising:     bool;
     p_pss_sem:               pss_sem 'ss 'v;
     (* transition_history:    list (trans 'ts 'ss); *)
  |>


type pts' = pts t

let p_initial_state
    (instruction_semantics:   instruction_semantics)
    (register_data:           registerdata)
    (state_record:            initial_state_record)
    : p_state (pts t) pss t
  =
  let prog = state_record.isr_program instruction_semantics in

  let initial_thread_states = 
    let init tid =
      PromisingThread.p_initial_thread_state
        state_record.isr_params.t
        tid
        prog
        (ensure_just (List.lookup tid state_record.isr_return_addr) "missing return address for thread")
        register_data
        (state_record.isr_register_data tid)
        (state_record.isr_register_values tid)
        (state_record.isr_first_instruction tid)
        state_record.isr_memory
    in
    [(tid, init tid) | forall (tid MEM state_record.isr_thread_ids) | true]
  in
  <| p_program_memory    = prog;
     p_initial_writes    = state_record.isr_memory;
     p_thread_states     = Map.fromList initial_thread_states;
     p_storage_state     = PromisingStorage.pss_initial_state state_record.isr_params
                               (Set.fromList state_record.isr_thread_ids)
                               state_record.isr_memory;
     p_model             = state_record.isr_params;
     p_instruction_semantics = instruction_semantics;
     p_stopped_promising = false;
     p_pss_sem = pss_sem;
  |>



(*** System ********************************************************************)

let promise_write (pss_sem : pss_sem 'pss 'v) (pts : pts 'v) (pss : 'pss) (wd : writedata 'v) shared 
    : list (pt_trans (pts 'v) ('pss) 'v) = 
  pss_sem.handle_write pss wd shared >>= fun (v,pss') ->
  let pts' = 
    let promise = (wd.wd_w.weiid,v,fst wd.wd_w.w_addr) in
    <| pts with promises = Set.insert promise pts.promises |>
  in
  return (PT_Write (wd.wd_w.w_thread, wd.wd_w.w_ioid) 
            (wd,Promise,shared) v (pts',pss'))


type certjob 'pts 'pss 'v =
  <| CJpts : 'pts;
     CJpss : 'pss;
     CJpss_view : 'v;
     CJpromises : set (writedata 'v);
     CJfulfilled : bool;
     CJcert_no_write : bool;
     CJfuel : nat; |>

type cert 'v = 
  | NotCertified
  | Certified of bool * set (writedata 'v)

let promisable = (le)


let make_apss pss pss_sem = <| pss_sem = pss_sem; pss = pss |>

let certprom_t params
    (isem : instruction_semantics)
    (pss_sem : pss_sem 'pss 'v)
    (cj : certjob (pts 'v) 'pss 'v)
    (trans : pt_trans (pts 'v) 'pss 'v)
  : certjob (pts 'v) 'pss 'v
  = 
  let (pts',pss') = tconf_after_pt_trans (cj.CJpts,cj.CJpss) trans in
  let shared_wds = Set.fromList (wd_of_shared_pt_write_trans trans) in
  let newp = {wd | forall (wd IN shared_wds) 
                 | promisable wd.wd_req_view cj.CJpss_view} in
  let promises = newp union cj.CJpromises in
  let cert_no_write = cj.CJcert_no_write && Set.null shared_wds in
  <| cj with CJpts = pts';
             CJpss = pss';
             CJpromises = promises;
             CJfuel = cj.CJfuel - 1; 
             CJcert_no_write = cert_no_write |>



let rec certprom_s params
    (isem : instruction_semantics)
    (pss_sem : pss_sem 'pss 'v)
    (cjs : list (certjob (pts 'v) 'pss 'v))
    (cert : cert 'v)
  : cert 'v =
  match cjs with
  | [] -> cert
  | cj :: cjs ->
    let fulfilled = cj.CJfulfilled || Set.null cj.CJpts.promises in
    let next_transitions = 
      if not (cj.CJfuel > 0) then
        let () = print_endline "\nWarning: ran out of fuel\n" in []
      else
        next_instruction_transitions_of_thread params
          isem cj.CJpts (make_apss cj.CJpss pss_sem)
    in 
    if not (List.null next_transitions) then
      let cj = <| cj with CJfulfilled = fulfilled |> in
      let new_cjs = List.map (certprom_t params isem pss_sem cj) next_transitions in
      certprom_s params isem pss_sem (new_cjs ++ cjs) cert
    else if not fulfilled then
      certprom_s params isem pss_sem cjs cert
    else
      let cert = 
        match cert with
        | NotCertified -> Certified cj.CJcert_no_write cj.CJpromises
        | Certified cert_no_write promises ->
           Certified (cert_no_write || cj.CJcert_no_write) 
                     (promises union cj.CJpromises)
        end in
      certprom_s params isem pss_sem cjs cert
  end

let certprom_transition params isem
      (pss_sem : pss_sem 'pss 'v)
      (pts : pts 'v)
      (pss : 'pss) tr = 
  let fulfilled = Set.null pts.promises in
  let no_write = List.null (wd_of_shared_pt_write_trans tr) in
  let cert = if fulfilled then Certified no_write Set.empty else NotCertified in
  let (pts',pss') = (tconf_after_pt_trans (pts,pss) tr) in
  let cj = <| CJpts = pts';
              CJpss = pss';
              CJpromises = Set.empty;
              CJfulfilled = fulfilled;
              CJpss_view = pss_sem.pss_view pss;
              CJfuel = params.t.thread_promising_fuel;
              CJcert_no_write = no_write;
           |> in
  certprom_s params isem pss_sem [cj] cert


let p_enumerate_transitions_of_thread
    (params : model_params)
    (isem : instruction_semantics)
    (pss_sem : pss_sem 'pss 'v)
    (stopped_promising : bool)
    (pts : pts 'v)
    (pss : 'pss)
    : maybe (list (p_trans (pts 'v) 'pss 'v * bool)) =  (* 'Nothing' indicates a deadlock *)

  if stopped_promising && quick_detect_deadlock pts then Nothing else

  let trs = next_instruction_transitions_of_thread params isem 
              pts (make_apss pss pss_sem) in

  let (transitions,promises) = 
    if stopped_promising
    then (List.map (fun tr -> (tr,true)) trs, Set.empty)
    else
      List.foldl (fun (trs,prms) tr ->
          match certprom_transition params isem pss_sem pts pss tr with
          | NotCertified -> (trs,prms)
          | Certified cert_no_write promises ->
             ((tr,cert_no_write) :: trs, prms union promises)
          end
        ) ([],Set.empty) trs 
  in


  (* If the same promise can be done with different required views,
     only enumerate transitions for with biggest required view. In the
     timestamp case whether minimal/maximal or maximal is not
     important (just need a unique one), since this "locally required
     view" does not matter: we do not record that view but the view of
     memory "before" doing this write. In the write-ids model it does
     matter. Picking the promise(s) with maximal view constrains the
     storage subsystem the most. But that strongest constraint on the
     storage subsystem should still be weaker than the corresponding
     storage state in the timestamp model. *)
    let promises = 
        {p | forall (p IN promises)
           | not (exists (p' IN promises).
                  (p.wd_w = p'.wd_w &&
                   p.wd_rexinfo = p'.wd_rexinfo &&
                   (p'.wd_req_view <> p.wd_req_view &&
                    le p.wd_req_view p'.wd_req_view) ))
        } in

  let promises = Set_extra.toList promises in

  let promise_transitions = 
    promises >>= fun wd ->
    promise_write pss_sem pts pss wd Shared >>= fun tr ->
    return (tr,false) in
  let transitions = transitions ++ promise_transitions in
  if List.null transitions && not (is_final_tstate params.t pts)
  then Nothing else Just (List.map (fun (t,b) -> (PT t,b)) transitions)



let rec enumerate_possible_final_states
    (params : model_params)
    (isem : instruction_semantics)
    (pss_sem : pss_sem 'pss 'v)
    (pts : pts 'v)
    (pss : 'pss)
      : list (pts 'v * 'pss)
  =
  if is_final_tstate params.t pts then return (pts,pss) else
    (* guard (quick_detect_deadlock pss pts) >> *)
    next_instruction_transitions_of_thread params isem pts 
      (make_apss pss pss_sem) >>= fun tr ->
    guard (not (is_shared_pt_write_trans tr)) >>
    let (pts,pss) = tconf_after_pt_trans (pts,pss) tr in
    enumerate_possible_final_states params isem pss_sem pts pss







val merge_combination :
  forall 'v 'pss. pss_sem 'pss 'v ->
  list (thread_id * (pts 'v * 'pss)) -> map thread_id (pts 'v) * 'pss
let merge_combination pss_sem combination =
  match combination with
    | [] -> failwith "merge_combinations"
    | (tid,(pts,pss)) :: rest ->
       let add (ptss,pss) (tid',(pts',pss')) =
         (Map.insert tid' pts' ptss, pss_sem.merge_pss_states pss pss')
       in
       List.foldl add (Map.singleton tid pts, pss) rest
  end



val all_combinations : forall 'a 'b. list ('a * list 'b) -> list (list ('a * 'b))
let rec all_combinations l = 
  match l with
  | [] -> [[]]
  | (a, bs) :: rest ->
     [(a,b) :: combinations 
        | forall (b MEM bs) (combinations MEM all_combinations rest) | true]
  end

let enumerate_finalise_transitions isem
      (state : p_state (pts 'v) 'pss 'v) = 
  if state.p_stopped_promising &&
       Map.all (fun _ ts -> is_final_tstate state.p_model.t ts) state.p_thread_states
  then []
  else
    let pss = state.p_storage_state in
    let ptss = Map_extra.toList state.p_thread_states in
    let (final_states_per_thread : list (thread_id * (list (pts 'v * 'pss)))) =
      List.map (fun (tid,pts) ->
          (tid, enumerate_possible_final_states state.p_model isem
                  state.p_pss_sem pts pss)) ptss in
    let (combinations : list (list (thread_id * (pts 'v * 'pss)))) = 
      all_combinations final_states_per_thread in
    List.map (merge_combination state.p_pss_sem) combinations


let p_enumerate_transitions
    (state:               p_state (pts 'v) 'pss 'v)
    (cached_sys_thread_trans: map thread_id (list (p_trans (pts 'v) 'pss 'v * bool)))
    : (list (p_trans (pts 'v) 'pss 'v)) * (map thread_id (list (p_trans (pts 'v) 'pss 'v * bool)))  
  =
  let stop_running =
    state.p_stopped_promising && not (state.p_model.t.thread_run_after_stop_promising) in

  if stop_running then
    let (possible_states : list (map thread_id (pts 'v) * 'pss)) =
      enumerate_finalise_transitions state.p_instruction_semantics state in
    let transitions = List.map (fun (ptss, pss) -> PSys_finish ptss pss) possible_states in
    let transitions' = Map.singleton 1000 (List.map (fun tr -> (tr,true)) transitions) in
    (transitions, transitions')
  else
  
  let stop_certifying =
    state.p_stopped_promising && not (state.p_model.t.thread_certify_after_stop_promising) in

  let sys_thread_transitions : map thread_id (list (p_trans (pts 'v) 'pss 'v * bool)) =

    let (transitions,_already_have_one,deadlock) : 
          (map thread_id (list (p_trans (pts 'v) 'pss 'v * bool)) * bool * bool) = 
      Map_extra.fold
        (fun tid ts (m,already_have_one,deadlock) ->
         match Map.lookup tid cached_sys_thread_trans with
         | Just [] -> (Map.insert tid [] m, already_have_one, deadlock)
         | Just trs -> (Map.insert tid trs m, true, deadlock)
         | Nothing ->
            if already_have_one && state.p_stopped_promising
            then (m,already_have_one,deadlock)
            else
              match p_enumerate_transitions_of_thread
                      state.p_model state.p_instruction_semantics 
                      state.p_pss_sem
                      stop_certifying ts
                      state.p_storage_state 
              with
              | Just [] -> (Map.insert tid [] m, false, deadlock)
              | Just trs -> (Map.insert tid trs m, true, deadlock)
              | Nothing -> (m, true, true)
              end
         end
        )
        state.p_thread_states (Map.empty,false,false)
    in

    if deadlock then Map.empty else transitions
  in


  let can_stop_promising = 
    not state.p_stopped_promising &&
    Map.all (fun tid trs ->
        let ts = Map_extra.find tid state.p_thread_states in
        is_final_tstate state.p_model.t ts || List.any snd trs)
      sys_thread_transitions
  in

  let stop_promising_transitions = 
    if can_stop_promising then [PSys_stop_promising] else []
  in

  let filter (tr,cert_no_write) = 
    ((state.p_model.t.thread_certify_after_stop_promising && state.p_stopped_promising) --> 
       cert_no_write) &&
    ((state.p_model.t.thread_certify_after_stop_promising && state.p_stopped_promising) --> 
       not (is_shared_p_write_trans tr)) &&
    ((state.p_model.ss.promise_first && not state.p_stopped_promising) --> 
      is_shared_p_write_trans tr)
  in
  let thread_transitions = 
    Map_extra.fold (fun _ trs acc -> acc ++ (List.filter filter trs))
      sys_thread_transitions []
  in

  ((List.map fst thread_transitions) ++ stop_promising_transitions, sys_thread_transitions)




let p_number_of_instructions s = 
  Map_extra.fold (fun _tid pts n -> n + (List.length pts.instrs)) s.p_thread_states 0

let p_is_ioid_finished (target_ioid : ioid) s : bool =
  let (thread_id, inst_id) = target_ioid in
  let thread = ensure_just (Map.lookup thread_id s.p_thread_states)
                           "No such thread" in
  isJust (List.find (fun i -> i.ii_ioid = target_ioid) thread.instrs)


type pst 'ts 'ss 'v =
  <| pst_state: p_state 'ts 'ss 'v;
     pst_trans: list (p_trans 'ts 'ss 'v);
  |>


let pst_of_state s =
  let (trans,_) = p_enumerate_transitions s Map.empty in
  <| pst_state = s; 
     pst_trans = trans |>




let pstate_after_transition (s : p_state (pts 'v) 'pss 'v) (t: p_trans (pts 'v) 'pss 'v)
    : p_state (pts 'v) 'pss 'v =
  match t with
  | PSys_thread_start _ _ _ _ -> fail
  | PSys_stop_promising -> 
     <| s with p_stopped_promising = true |>
  | PSys_finish ptss pss -> 
     <| s with p_thread_states = ptss; p_storage_state = pss |>
  | PT t -> 
     let tid = tid_of_pt_trans t in
     let pts = Map_extra.find tid s.p_thread_states in
     let (pts,pss) = tconf_after_pt_trans (pts,s.p_storage_state) t in
     <| s with p_thread_states = Map.insert tid pts s.p_thread_states;
               p_storage_state = pss |>
  end





let pst_after_transition
    (s:         pst (pts 'v) 'pss 'v)
    (t:         p_trans (pts 'v) 'pss 'v)
    : transition_outcome (pst (pts 'v) 'pss 'v)
  =
  TO_system_state (pst_of_state (pstate_after_transition s.pst_state t))
  

let p_is_final_state (s : p_state (pts 'v) 'pss 'v) : bool =
  s.p_model.ss.promise_first --> s.p_stopped_promising &&
  (* quantify over list rather than set to avoid needing set type for thread states *)
  (forall ((_,ts) MEM (Map_extra.toList s.p_thread_states)).
   PromisingThread.is_final_tstate s.p_model.t ts)




(* This does not produce all the information cex would like to have,
   should fix later *)
let p_make_cex_instruction_info
    (* (_prefix: list instruction_info) *)
    (i:      instruction_info)
    : cex_instruction_instance
  =
  <|
    cex_instance_ioid = i.ii_ioid;
    cex_program_loc = i.ii_program_loc;
    cex_program_opcode = i.ii_program_opcode;
    cex_instruction = i.ii_instruction; 
    cex_instruction_kind = i.ii_kind;
    (* register part *)
    cex_regs_in = Set.fromList (List.map fst i.ii_reg_reads);
    cex_regs_out = Set.fromList (List.map fst i.ii_reg_writes);
    cex_regs_in_feeding_address = Set.fromList i.ii_regs_feeding_address;
    cex_ioids_feeding_address = Set.empty;
    cex_reg_reads = List.map (fun (r,v) -> (r,[],v)) i.ii_reg_reads;
    cex_reg_writes = i.ii_reg_writes;
    (* memory part *)
    cex_writes_read_from = Set.fromList (List.concatMap snd i.ii_writes_read_from);
    cex_committed_barriers = [];
    cex_potential_write_addresses = [];
    cex_potential_writes = [];
    cex_propagated_writes = i.ii_propagated_writes;
    cex_requested_unsatisfied_reads = [];
    cex_satisfied_reads =
      List.mapMaybe
        (fun (rr, writes_read_from) ->
          let mrs =
            <|  mrs_footprint        = rr.r_addr;
                mrs_value            = value_of_write_slices writes_read_from;
                mrs_writes_read_from = writes_read_from;
            |>
          in
          Just (rr, mrs)
        )
        i.ii_writes_read_from;
    (* status *)
    cex_finished = true;

    (* dependencies *)
    cex_address_dependencies = Set.empty;
    cex_data_dependencies = Set.empty;
    cex_control_dependencies = Set.empty;
    cex_paired_atomic_load = Nothing;
  |>


let p_make_cex_instruction_tree (iis:list instruction_info) : cex_instruction_tree =
  List.foldr (fun ii t -> CEX_T [(p_make_cex_instruction_info ii,t)]) (CEX_T []) iis


let p_make_cex_thread_state (t : pts 'v) : cex_thread_state = 
  <| cex_thread = t.tid;
     cex_register_data = t.regdata;
     cex_initial_register_state = t.initRegS;
     cex_initial_fetch_address = t.initAddr;
     cex_instruction_tree = p_make_cex_instruction_tree t.instrs;
  |>

val p_make_cex_candidate : forall 'v. p_state (pts 'v) pss 'v -> cex_candidate
let p_make_cex_candidate s : cex_candidate =
  let rf =
    let instructions =
      Map.map (fun t -> Set.fromList t.instrs) s.p_thread_states $>
      Map.range $> Set.bigunion 
    in
    Set.bigunionMap
      (fun i ->
        List.concatMap
          (fun (r, wss) -> [(ws, r) | forall (ws MEM wss) |true])
          i.ii_writes_read_from
        $> Set.fromList
      )
      instructions
  in

  let co = pss_coherence s.p_storage_state in

  let fr =
    let rfConverse = {(r, w) | forall (((w, _), r) IN rf) | true} in
    Relation.relComp rfConverse co
    $> Set.filter (fun (r,w) -> non_empty_intersection r.r_addr w.w_addr)
  in

  <|
    cex_program_memory = s.p_program_memory;
    cex_initial_writes = s.p_initial_writes;
    cex_threads = Map.map p_make_cex_thread_state s.p_thread_states;
    cex_rf = rf;
    cex_co = Relation.withoutTransitiveEdges co;
    cex_fr = fr;
    cex_model = s.p_model;
  |> 


let p_branch_targets_of_state _  : branch_targets_map = Map.empty
let p_shared_memory_of_state _ : set footprint = Set.empty





(* To easier refer to these in OCaml .. *)
let type_specialised_p_pst_of_state (s : p_state (pts t) pss t) = pst_of_state s
let type_specialised_p_is_final_state (s : p_state (pts t) pss t) = p_is_final_state s
let type_specialised_pst_after_transition
      (s:         pst (pts t) pss t)
      (t:         p_trans (pts t) pss t)
  = pst_after_transition s t
