open import Pervasives
open import Sail_impl_base
open import BasicTypes
open import InstructionSemantics
open import Fragments
open import PromisingViews
open import Params
open import Events
open import Utils
open import Assert_extra
open ListMonad

type writedata 'v = 
  <| wd_w : write; 
     wd_rexinfo : maybe (w_eiid * address); 
     wd_req_view : 'v |>   


type pthread_label 'request 'answer 'ts =
  <|  ptl_label: 'request;
      ptl_suppl: maybe 'answer;
      ptl_cont: 'answer -> 'ts;
      ptl_ioid: ioid;
      ptl_tid: thread_id;
  |>

let make_plabel (tid : thread_id) (ioid : ioid)
    (label:  'request)
    (cont: 'answer -> 'ts)
    : pthread_label 'request 'answer 'ts
  =
  <|  ptl_label = label;
      ptl_suppl = Nothing;
      ptl_cont  = cont;
      ptl_ioid  = ioid;
      ptl_tid   = tid;
  |>


(* thread transitions which involve interaction with the storage
subsystem when taken *)
(** NOTE: ALL THE CONSTRUCTORS SHOULD HAVE THE TYPE "thread_label 'l 's" *)
type pthread_sync_label 'ts 'v =
  (*** Promising: ***)
  | PT_Write of pthread_label
      (writedata 'v * bool) 
      (maybe 'v)
      'ts
  | PT_Fulfil of pthread_label
      (writedata 'v)
      (maybe 'v)
      'ts
  | PT_Read of pthread_label
      (read_request * 'v)
      (maybe (write * 'v))
      'ts 
  | PT_Write_nonshared of pthread_label
      (writedata 'v) (* whether promising *)
      (maybe 'v)
      'ts
  | PT_Read_nonshared of pthread_label
      (read_request * 'v)
      (maybe (write * 'v))
      'ts 

type pthread_only_trans =
  | PT_finish of address * instruction_ast
  | PT_failed_store_excl
  | PT_exception of exception_type




type pthread_trans_t 'ssc 'ts 'v =
  | PT_only         of pthread_label pthread_only_trans unit 'ts
  | PT_sync         of pthread_sync_label 'ts 'v * 'ssc (* 'ssc: see types below *)
  | PT_thread_start of
      pthread_label
        (register_value * maybe register_value) (* (opd address, opd toc), only PPCGEN has toc *)
        (maybe thread_id) (* the tid of the new thread *)
        'ts

(* when the transition is generated by the thread 'ssc is unit; after
the transition is synced with storage 'ssc is the storage continuation *)
type pthread_trans 'ts 'v = pthread_trans_t unit 'ts 'v
type psys_thread_trans 'ts 'ss 'v = pthread_trans_t (maybe (unit -> 'ss)) 'ts 'v


type pss_only_trans 'pss = 
  PSS_stop_promising of (unit -> 'pss)

(* all the system transitions; this is a union of the storage and thread
transitions, with 'tc and 'ssc (respectively) providing extra continuations
for the synced counter part (thread/storage) *)
type ptrans 'ts 'ss 'v =
  | PSS_trans of pss_only_trans 'ss
  | PT_trans  of psys_thread_trans 'ts 'ss 'v
  | PSys_trans of map thread_id 'ts * 'ss    




let tid_of_pthread_sync_trans = function
  | PT_Write tl  -> tl.ptl_tid
  | PT_Fulfil tl -> tl.ptl_tid
  | PT_Read tl   -> tl.ptl_tid
  | PT_Write_nonshared tl -> tl.ptl_tid
  | PT_Read_nonshared tl  -> tl.ptl_tid
end

let tid_of_pthread_trans_t = function
  | PT_only ptl -> ptl.ptl_tid
  | PT_sync t _ -> tid_of_pthread_sync_trans t
  | PT_thread_start ptl -> ptl.ptl_tid
end

let ioid_of_pthread_sync_trans = function
  | PT_Fulfil tl -> tl.ptl_ioid
  | PT_Write tl  -> tl.ptl_ioid
  | PT_Read tl   -> tl.ptl_ioid
  | PT_Write_nonshared tl -> tl.ptl_ioid
  | PT_Read_nonshared tl  -> tl.ptl_ioid
end

let ioid_of_pthread_trans_t = function
  | PT_only ptl -> ptl.ptl_ioid
  | PT_sync t _ -> ioid_of_pthread_sync_trans t
  | PT_thread_start ptl -> ptl.ptl_ioid
end

let thread_id_of_pthread_trans : ptrans 'ts 'ss 'v -> maybe thread_id = function
  | PSS_trans _ -> Nothing
  | PT_trans t  -> Just (tid_of_pthread_trans_t t)
  | PSys_trans _ _ -> Nothing
  end

let ioid_of_pthread_trans = function
  | PT_trans t -> Just (ioid_of_pthread_trans_t t)
  | _ -> Nothing
end

let principal_ioid_of_ptrans = ioid_of_pthread_trans


let p_is_storage_transition : ptrans 'ts 'ss 'v -> bool = function
  | PSS_trans _ -> true
  | PT_trans _  -> false
  | PSys_trans _ _ -> false
  end

let p_is_thread_transition : ptrans 'ts 'ss 'v -> bool = function
  | PSS_trans _ -> false
  | PT_trans _  -> true
  | PSys_trans _ _ -> false
  end



let wd_of_prop_trans = function
  | (PT_sync (PT_Write tl) _) -> return (fst tl.ptl_label)
  | (PT_sync (PT_Write_nonshared tl) _) -> return tl.ptl_label
  | _ -> mzero
end

let wd_of_shared_prop_trans = function
  | (PT_sync (PT_Write tl) _) -> Set.singleton (fst tl.ptl_label)
  | _ -> Set.empty
end

let wd_of_trans = function
  | (PT_sync (PT_Fulfil tl) _) -> return tl.ptl_label
  | (PT_sync (PT_Write tl) _) -> return (fst tl.ptl_label)
  | (PT_sync (PT_Write_nonshared tl) _) -> return tl.ptl_label
  | _ -> mzero
end

let unlockA_of_wd wd = option_guard wd.wd_rexinfo

let is_shared_write : psys_thread_trans 'ts 'ss 'v -> bool = function
  | (PT_sync (PT_Write _) _) -> true
  | _ -> false
end

let is_shared_write_trans : ptrans 'ts 'ss 'v -> bool = function
  | PT_trans (PT_sync (PT_Write _) _) -> true
  | _ -> false
end

let is_stop_promising : ptrans 'ts 'ss 'v -> bool = function
  | PSS_trans (PSS_stop_promising _)  -> true
  | _ -> false
end

let is_write : ptrans 'ts 'ss 'v -> bool = function
  | PT_trans (PT_sync (PT_Write _) _) -> true
  | PT_trans (PT_sync (PT_Write_nonshared _) _) -> true
  | _ -> false
end


let ts_ss_after_psys_thread_trans old_memory : psys_thread_trans 'pts 'pss 'v -> ('pts * 'pss) = function
  | (PT_only tl) -> 
     (tl.ptl_cont (), old_memory)

  | (PT_sync (PT_Read tl) Nothing) -> 
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, old_memory)

  | (PT_sync (PT_Read tl) (Just mc)) -> 
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, mc ())

  | (PT_sync (PT_Read_nonshared tl) Nothing) -> 
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, old_memory)

  | (PT_sync (PT_Write tl) (Just mc)) ->
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, mc ())

  | (PT_sync (PT_Write_nonshared tl) (Just mc)) ->
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, mc ())

  | (PT_sync (PT_Fulfil tl) Nothing) ->
     let answer = ensure_just tl.ptl_suppl "fail" in
     (tl.ptl_cont answer, old_memory)

  | _ -> fail
  end



let ptrans_fetch_address : ptrans 'ts 'ss 'v -> maybe address = function
  | _ -> Nothing
  end

let read_footprint_of_ptrans (transition: ptrans 'ts 'ss 'v) : maybe footprint =
  match transition with
  | PSS_trans _ -> Nothing
  | PSys_trans _ _ -> Nothing
  | PT_trans (PT_sync (PT_Read ptl) _) ->
     Just (fst ptl.ptl_label).r_addr
  | PT_trans (PT_sync (PT_Read_nonshared ptl) _) ->
     Just (fst ptl.ptl_label).r_addr
  | PT_trans _ -> Nothing
  end

let ptrans_reads_footprint
    (footprint:  footprint)
    (transition: ptrans 'ts 'ss 't)
    : bool
  =
  read_footprint_of_ptrans transition
  $> Maybe.map (non_empty_intersection footprint)
  $> fromMaybe false



(* NOTE: write_footprints_of_trans is (also) used to determine if the
transition can be taken eagerly when eager_local_mem is enabled *)
let write_footprints_of_ptrans (transition: ptrans 'ts 'ss 'v) : list footprint =
  match transition with
  | PSS_trans _ -> []
  | PSys_trans _ _ -> []
  | PT_trans t -> List.map (fun wd -> wd.wd_w.w_addr) (wd_of_prop_trans t)
  end

let ptrans_writes_footprint
    (footprint:  footprint)
    (transition: ptrans 'ts 'ss 'v)
    : bool
  =
  exists (fp MEM (write_footprints_of_ptrans transition)).
      non_empty_intersection footprint fp



let p_priority_transitions params (ss_final_state : bool) (_: eager_mode) :
      list ((ptrans 'ts 'ss 'v -> bool) * bool) =
  match params.t.thread_model with
  | Promising_thread_model -> (* also see optimised transition enumeration *)
     if not params.ss.promise_first then
       []
     else if ss_final_state && not (params.t.thread_run_after_stop_promising) then
       []
     else if ss_final_state (* stopped_promising = true *) then
       (* [(fun t -> not (is_shared_write_trans t), true); *)
        [(fun t -> true, true)] 
     else
       [(fun t -> is_shared_write_trans t || is_stop_promising t, false)]
  | _ -> []
end
  


