open import Pervasives
open import Sail_impl_base
open import MachineDefEvents
open import MachineDefISAInfo


(** model parameters *)
(*: \subsection{Model Parameters} :*)

type propagate_write_params =
  | Only_at_end
  | Possibly_in_middle

type new_coherence_params =
  | Use_new_coherence
  | Use_old_coherence
  | Check_new_vs_old

type storage_model =
  | PLDI11_storage_model
  | Flowing_storage_model
  | Flat_storage_model
  | POP_storage_model
  | NOP_storage_model
  | TSO_storage_model
  | Promising_storage_model

type flowing_topology =
  | FTopo_leaf of thread_id
  | FTopo_join of list flowing_topology

type ss_params =
  <| ss_model: storage_model;
     ss_sc   : bool; (* behave like SC *)
     pw      : propagate_write_params;
     new_coh : new_coherence_params;

     (* parameters for Flowing *)
     flowing_topology : flowing_topology;

     promise_first: bool;
  |>


type thread_flowing_same_address_params =
  | Flowing_same_address_strict
  | Flowing_same_address_aggressive

type thread_restrict_write_commit_params =
  | Forbid_prev_uncommitted_read_type0
  | Allow_prev_uncommitted_determined_addr_read_type1

type thread_restart_read_params =
  | Restart_on_commit
  | Restart_on_read_satisfy

type pop_thread_model =
  | Standard_POP
  | Flat_POP

type thread_model =
  | PLDI11_thread_model
  | POP_thread_model of pop_thread_model
  | TSO_thread_model
  | Promising_thread_model
  | Relaxed_thread_model  (* A bit of a hack! This is a very relaxed model
                          intended to be used with 'rmem -dot_final_ok true ...'.
                          It should allow all litmus tests that don't
                          have a "data | addr | rf | fr" cycle.
                          To be used together with flat-storage. *)

type thread_restriction =
  | RestrictionNone
  | RestrictionSC      (* sequential consistency *)
  | RestrictionSCANASC (* single-copy-atomic non-atomic-sequential-consistency *)


type branch_targets_map = map thread_id (map address (set address))


type thread_params =
  <| thread_model:       thread_model;
     thread_restriction: thread_restriction; (* additional model restrictions *)
     thread_fsa:         thread_flowing_same_address_params;
     thread_rwc:         thread_restrict_write_commit_params;
     thread_rr:          thread_restart_read_params;
     thread_allow_tree_speculation:  bool;
     thread_allow_write_subsumption: bool;
     thread_fail_on_loop:            bool;
     thread_isa_info :               isa_info;
     thread_loop_unroll_limit:       maybe nat;

     branch_targets: branch_targets_map;

     thread_run_after_stop_promising : bool;
     thread_certify_after_stop_promising : bool;
     thread_promising_fuel : nat;

     promising_partial_order : bool;
  |>


type model_params =
  <| ss:             ss_params;
     t:              thread_params;

     (* shared_memory: this is an over approximation of the shared memory
     locations. Used by Promising. *)
     shared_memory:  maybe (set footprint)
  |>


let is_pop_model params = match params.thread_model with
  | POP_thread_model _ -> true
  | _ -> false
end

let is_flat_model params = match params.thread_model with
  | POP_thread_model Flat_POP -> true
  | _ -> false
end


type eager_mode =
  <|
    eager_fetch_single:        bool;
    eager_fetch_multi:         bool;
    eager_pseudocode_internal: bool;
    eager_constant_reg_read:   bool;
    eager_reg_rw:              bool;
    eager_memory_aux:          bool;
    eager_finish:              bool;
    eager_fp_recalc:           bool;
    eager_thread_start:        bool;

    eager_local_mem:           bool;
    em_shared_memory:          set footprint;
  |>
