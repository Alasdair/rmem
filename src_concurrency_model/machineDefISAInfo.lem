open import Pervasives_extra
open import Sail_impl_base
open import MachineDefEvents
open import MachineDefUtils
     import MachineDefInstructionSemantics

(* the left nat is width and the right nat is initial index;
the list is the register fields; if direction is D_increasing the left side of the
slice is less or equal to the right, if direction is D_decreasing the right side of the
slice is less or equal to the left *)
type registerdata = list (reg_base_name * (direction * nat * nat * list (string * slice)))

let reg_from_data (data: registerdata) (name: reg_base_name) : maybe reg_name =
  Maybe.bind (List.lookup name data) $ fun (direction, width, start, _) ->
  Just (Reg name start width direction)

let reg_field_from_data (data: registerdata) (name: reg_base_name) (field_name: string) : maybe reg_name =
  Maybe.bind (List.lookup name data) $ fun (direction, width, start, fields) ->
  Maybe.bind (List.lookup field_name fields) $ fun slice ->
  let norm (d: direction) (start: nat) (i, j) = (* see interp_inter_imp.lem extern_slice *)
    match d with
    | D_increasing -> (i, j)
    | D_decreasing ->
        let i' = start - i in
        let j' = (i - j) + i' in
        (i', j')
    end
  in
  Just (Reg_field name start direction field_name (norm direction start slice))

let fixed_reg (data: registerdata) value (name: reg_base_name) =
  let reg = Maybe_extra.fromJust (reg_from_data data name) in
  (reg, register_value_for_reg_of_integer reg value)

let fixed_reg_field (data: registerdata) value (name: reg_base_name) (field_name: string) =
  let reg = Maybe_extra.fromJust (reg_field_from_data data name field_name) in
  (reg, register_value_for_reg_of_integer reg value)



type thread_start_info =
  <|  (* these registers hold the arguments of the thread_start function *)
      tsi_addr:   reg_name;
      tsi_toc:    maybe reg_name; (* PPCGEN *)
      tsi_extra:  maybe reg_name; (* PPCGEN, though unused *)
      (* this register holds the value returned by the thread_start function *)
      tsi_return: reg_name;

      (* these registers hold the arguments of the new thread function *)
      tsi_f_tid:  reg_name;
      tsi_f_toc:  maybe reg_name; (* PPCGEN *)
      tsi_f_addr: maybe reg_name; (* MIPS *)
  |>

let thread_start_info_stub =
  <|  tsi_addr  = Reg "" 0 0 D_increasing;
      tsi_toc   = Nothing;
      tsi_extra = Nothing;
      tsi_return = Reg "" 0 0 D_increasing;
      tsi_f_tid  = Reg "" 0 0 D_increasing;
      tsi_f_toc  = Nothing;
      tsi_f_addr = Nothing;
  |>


type isa_info =
  <|  ism : MachineDefInstructionSemantics.instruction_semantics_mode;
      is_system_call_instruction  : MachineDefInstructionSemantics.instruction_ast -> maybe integer;
      is_thread_start_instruction : MachineDefInstructionSemantics.instruction_ast -> bool;

      thread_start_info : thread_start_info;

      register_data_info     : registerdata;
      fixed_pseudo_registers : list (reg_name * register_value);
      cia_reg                : reg_name;
      nia_reg                : reg_name;
      dia_reg                : maybe reg_name;

      make_empty_write_events  : thread_id -> 
                                 MachineDefInstructionSemantics.instruction_ast -> (* instruction instance's AST node *)
                                 MachineDefFreshIds.id_state ioid -> (* instruction instance's id state *)
                                 ioid -> (* instruction instance's id *)
                                 footprint ->
                                 write_kind ->
                                 ((list write) * (MachineDefFreshIds.id_state ioid));
      make_read_request_events : thread_id ->
                                 MachineDefInstructionSemantics.instruction_ast -> (* instruction instance's AST node *)
                                 MachineDefFreshIds.id_state ioid -> (* instruction instance's id state *)
                                 ioid -> (* instruction instance's id *)
                                 footprint ->
                                 read_kind ->
                                 ((list read_request) * (MachineDefFreshIds.id_state ioid))
  |>

let isa_info_stub =
  <|  ism                         = MachineDefInstructionSemantics.PPCGEN_ism;
      is_system_call_instruction  = fun _ -> failwith "stub";
      is_thread_start_instruction = fun _ -> failwith "stub";
      thread_start_info           = thread_start_info_stub;
      register_data_info          = [];
      fixed_pseudo_registers      = [];
      cia_reg                     = Reg "" 0 0 D_increasing;
      nia_reg                     = Reg "" 0 0 D_increasing;
      dia_reg                     = Nothing;
      make_empty_write_events     = fun _ _ _ _ -> failwith "stub";
      make_read_request_events    = fun _ _ _ _ -> failwith "stub";
  |>
