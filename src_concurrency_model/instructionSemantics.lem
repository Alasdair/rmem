(*===============================================================================*)
(*                                                                               *)
(*                rmem executable model                                          *)
(*                =====================                                          *)
(*                                                                               *)
(*  This file is:                                                                *)
(*                                                                               *)
(*  Copyright Jon French, University of Cambridge                2018            *)
(*  Copyright Christopher Pulte, University of Cambridge    2017-2018            *)
(*  Copyright Shaked Flur, University of Cambridge          2017-2018            *)
(*  Copyright Robert Norton-Wright, University of Cambridge      2017            *)
(*                                                                               *)
(*  All rights reserved.                                                         *)
(*                                                                               *)
(*  It is part of the rmem tool, distributed under the 2-clause BSD licence in   *)
(*  LICENCE.txt.                                                                 *)
(*                                                                               *)
(*===============================================================================*)

open import Pervasives_extra

(* emacs fontification -*-caml-*- *)

open import Sail_impl_base
open import Utils
open import Sail_values
       import Sail2_values
       import Riscv_types
       import Sail2_prompt_monad
       import Sail2_operators_mwords
import Prompt
import Power_embed
import Mips_embed
import X86_embed
import Riscv
import ArmV8


type aarch64_variant =
  | AArch64HandSail   (* hand written ISA model *)
  | AArch64GenSail    (* auto-generated ISA model *)

type instruction_semantics_mode (* ism *) =
  | PPCGEN_ism
  | AARCH64_ism of aarch64_variant
  | MIPS_ism
  | RISCV_ism
  | X86_ism

type instruction_ast =
  | PPCGEN_instr of Power_embed_types.ast
  | AArch64_instr of ArmV8_types.ast
  | MIPS_instr of Mips_embed_types.ast
  | RISCV_instr of Riscv_types.ast
  | X86_instr of X86_embed_types.ast
  | Fetch_error


type decode_error_t =
  | Unsupported_instruction_error of opcode * instruction_ast
  | Not_an_instruction_error of opcode
  | Internal_decode_error of string

type fetch_and_decode_outcome =
  | FDO_success of address * (maybe opcode) * instruction_ast
  | FDO_address_not_concrete
  | FDO_illegal_fetch_address
  | FDO_decode_error of decode_error_t


let decode_error_compare e1 e2 =
  match (e1, e2) with
  (* we assume 'opcode' deterministically defines 'instruction_ast' so we only
  compare 'opcode', also it's hard to auto-gen compare for 'instruction_ast' *)
  | (Unsupported_instruction_error a1 _, Unsupported_instruction_error a2 _)
      -> compare a1 a2
  | (Unsupported_instruction_error _ _, _) -> LT
  | (_, Unsupported_instruction_error _ _) -> GT

  | (Not_an_instruction_error o1, Not_an_instruction_error o2) -> compare o1 o2
  | (Not_an_instruction_error _, _) -> LT
  | (_, Not_an_instruction_error _) -> GT

  | (Internal_decode_error s1, Internal_decode_error s2) -> compare s1 s2
  end

let decode_error_less e1 e2       = decode_error_compare e1 e2 =  LT
let decode_error_less_eq e1 e2    = decode_error_compare e1 e2 <> GT
let decode_error_greater e1 e2    = decode_error_compare e1 e2 =  GT
let decode_error_greater_eq e1 e2 = decode_error_compare e1 e2 <> LT

instance (Ord decode_error_t)
  let compare = decode_error_compare
  let (<)  = decode_error_less
  let (<=) = decode_error_less_eq
  let (>)  = decode_error_greater
  let (>=) = decode_error_greater_eq
end

let {coq; ocaml} decode_error_equal e1 e2 = (decode_error_compare e1 e2) = EQ
let inline {hol; isabelle} decode_error_equal = unsafe_structural_equality

let {coq; ocaml} decode_error_inequal e1 e2 = not (decode_error_equal e1 e2)
let inline {hol; isabelle} decode_error_inequal = unsafe_structural_inequality

instance  (Eq decode_error_t)
  let (=)  = decode_error_equal
  let (<>) = decode_error_inequal
end

type instruction_semantics =
  <| initial_outcome_s_of_instruction: instruction_ast -> outcome_S;
     instruction_analysis :
       outcome_S (* the current outcome for the interpreter *) ->
       instruction_ast ->
       string (*analysis function*) ->
       (string -> (Maybe.maybe string) -> (nat*nat*direction*(nat*nat))) (* reginfo*) ->
       reg_name (* nia_reg *) ->
       list (reg_name * register_value) ->
       (list reg_name * list reg_name * list reg_name * list nia * dia * instruction_kind);
     decode_to_instruction : address -> opcode -> fetch_and_decode_outcome;
  |>


let sail_bit_1to2 b =
  match b with
  | Sail_values.B0 -> Sail2_values.B0
  | Sail_values.B1 -> Sail2_values.B1
  | Sail_values.BU -> Sail2_values.BU
end

let sail_bit_2to1 b =
  match b with
  | Sail2_values.B0 -> Sail_values.B0
  | Sail2_values.B1 -> Sail_values.B1
  | Sail2_values.BU -> Sail_values.BU
end

let bitl_of_bitU b =
  match b with
  | Sail_values.B1 -> Bitl_one
  | Sail_values.B0 -> Bitl_zero
  | Sail_values.BU -> Bitl_undef
  end
   
let bitU_of_bitl b =
  match b with
  | Bitl_one -> Sail_values.B1
  | Bitl_zero -> Sail_values.B0
  | Bitl_undef -> Sail_values.BU
  | Bitl_unknown -> Sail_values.BU
  end

let bool_to_bitU b =
  match b with
  | true -> Sail_values.B1
  | false -> Sail_values.B0
  end

let bool_to_bitl b =
  match b with
  | true -> Sail_impl_base.Bitl_one
  | false -> Sail_impl_base.Bitl_zero
  end

val sail_bv_1to2 : Sail_values.vector Sail_values.bitU -> list Sail2_values.bitU
let sail_bv_1to2 vec =
  (* TODO FIXME start and direction *)
  if Sail_values.get_dir vec <> false then failwith "non-decreasing vector seen by sail_bv_1to2" else
    (* if Sail_values.get_start vec <> 63 then failwith "non-63-start vector seen by sail_bv_1to2" else *)
    List.map sail_bit_1to2 (Sail_values.get_elems vec)

let riscv_bits_to_sail1_vec bv =
  (Sail_values.Vector (List.map bool_to_bitU (Machine_word.bitlistFromWord bv)) (integerFromNat (Machine_word.word_length bv)) false)

let armv8_bits_to_sail1_vec bv =
  (Sail_values.Vector (List.map sail_bit_2to1 bv) (integerFromNat (List.length bv)) false)

let riscv_bk_to_sail1 bk =
  match bk with
  | Sail2_instr_kinds.Barrier_Sync        -> Sail_impl_base.Barrier_Sync
  | Sail2_instr_kinds.Barrier_LwSync      -> Sail_impl_base.Barrier_LwSync
  | Sail2_instr_kinds.Barrier_Eieio       -> Sail_impl_base.Barrier_Eieio
  | Sail2_instr_kinds.Barrier_Isync       -> Sail_impl_base.Barrier_Isync
  | Sail2_instr_kinds.Barrier_DMB         -> Sail_impl_base.Barrier_DMB
  | Sail2_instr_kinds.Barrier_DMB_ST      -> Sail_impl_base.Barrier_DMB_ST
  | Sail2_instr_kinds.Barrier_DMB_LD      -> Sail_impl_base.Barrier_DMB_LD
  | Sail2_instr_kinds.Barrier_DSB         -> Sail_impl_base.Barrier_DSB
  | Sail2_instr_kinds.Barrier_DSB_ST      -> Sail_impl_base.Barrier_DSB_ST
  | Sail2_instr_kinds.Barrier_DSB_LD      -> Sail_impl_base.Barrier_DSB_LD
  | Sail2_instr_kinds.Barrier_ISB         -> Sail_impl_base.Barrier_ISB
  | Sail2_instr_kinds.Barrier_TM_COMMIT   -> Sail_impl_base.Barrier_TM_COMMIT
  | Sail2_instr_kinds.Barrier_MIPS_SYNC   -> Sail_impl_base.Barrier_MIPS_SYNC
  | Sail2_instr_kinds.Barrier_RISCV_rw_rw -> Sail_impl_base.Barrier_RISCV_rw_rw
  | Sail2_instr_kinds.Barrier_RISCV_r_rw  -> Sail_impl_base.Barrier_RISCV_r_rw
  | Sail2_instr_kinds.Barrier_RISCV_r_r   -> Sail_impl_base.Barrier_RISCV_r_r
  | Sail2_instr_kinds.Barrier_RISCV_rw_w  -> Sail_impl_base.Barrier_RISCV_rw_w
  | Sail2_instr_kinds.Barrier_RISCV_w_w   -> Sail_impl_base.Barrier_RISCV_w_w
  | Sail2_instr_kinds.Barrier_RISCV_w_rw  -> Sail_impl_base.Barrier_RISCV_w_rw
  | Sail2_instr_kinds.Barrier_RISCV_rw_r  -> Sail_impl_base.Barrier_RISCV_rw_r
  | Sail2_instr_kinds.Barrier_RISCV_r_w   -> Sail_impl_base.Barrier_RISCV_r_w
  | Sail2_instr_kinds.Barrier_RISCV_w_r   -> Sail_impl_base.Barrier_RISCV_w_r
  | Sail2_instr_kinds.Barrier_RISCV_tso   -> Sail_impl_base.Barrier_RISCV_tso
  | Sail2_instr_kinds.Barrier_RISCV_i     -> Sail_impl_base.Barrier_RISCV_i
  | Sail2_instr_kinds.Barrier_x86_MFENCE  -> Sail_impl_base.Barrier_x86_MFENCE
end

let riscv_rk_to_sail1 rk =
  match rk with
    | Sail2_instr_kinds.Read_plain                         -> Sail_impl_base.Read_plain
    | Sail2_instr_kinds.Read_reserve                       -> Sail_impl_base.Read_reserve
    | Sail2_instr_kinds.Read_acquire                       -> Sail_impl_base.Read_acquire
    | Sail2_instr_kinds.Read_exclusive                     -> Sail_impl_base.Read_exclusive
    | Sail2_instr_kinds.Read_exclusive_acquire             -> Sail_impl_base.Read_exclusive_acquire
    | Sail2_instr_kinds.Read_stream                        -> Sail_impl_base.Read_stream
    | Sail2_instr_kinds.Read_RISCV_acquire                 -> Sail_impl_base.Read_RISCV_acquire_RCpc
    | Sail2_instr_kinds.Read_RISCV_strong_acquire          -> Sail_impl_base.Read_RISCV_acquire_RCsc
    | Sail2_instr_kinds.Read_RISCV_reserved                -> Sail_impl_base.Read_RISCV_reserved
    | Sail2_instr_kinds.Read_RISCV_reserved_acquire        -> Sail_impl_base.Read_RISCV_reserved_acquire_RCsc
    | Sail2_instr_kinds.Read_RISCV_reserved_strong_acquire -> Sail_impl_base.Read_RISCV_reserved_acquire_release
    | Sail2_instr_kinds.Read_X86_locked                    -> Sail_impl_base.Read_X86_locked
  end

let riscv_wk_to_sail1 wk =
  match wk with
  | Sail2_instr_kinds.Write_plain                            -> Sail_impl_base.Write_plain
  | Sail2_instr_kinds.Write_conditional                      -> Sail_impl_base.Write_conditional
  | Sail2_instr_kinds.Write_release                          -> Sail_impl_base.Write_release
  | Sail2_instr_kinds.Write_exclusive                        -> Sail_impl_base.Write_exclusive
  | Sail2_instr_kinds.Write_exclusive_release                -> Sail_impl_base.Write_exclusive_release
  | Sail2_instr_kinds.Write_RISCV_release                    -> Sail_impl_base.Write_RISCV_release_RCpc
  | Sail2_instr_kinds.Write_RISCV_strong_release             -> Sail_impl_base.Write_RISCV_release_RCsc
  | Sail2_instr_kinds.Write_RISCV_conditional                -> Sail_impl_base.Write_RISCV_conditional
  | Sail2_instr_kinds.Write_RISCV_conditional_release        -> Sail_impl_base.Write_RISCV_conditional_release_RCsc
  | Sail2_instr_kinds.Write_RISCV_conditional_strong_release -> Sail_impl_base.Write_RISCV_conditional_acquire_release
  | Sail2_instr_kinds.Write_X86_locked                       -> Sail_impl_base.Write_X86_locked
  end

let riscv_tk_to_sail1 tk =
  match tk with
  | Sail2_instr_kinds.Transaction_start  -> Sail_impl_base.Transaction_start
  | Sail2_instr_kinds.Transaction_commit -> Sail_impl_base.Transaction_commit
  | Sail2_instr_kinds.Transaction_abort  -> Sail_impl_base.Transaction_abort
  end

let riscv_ck_to_sail1 ck =
  match ck with
  | Sail2_instr_kinds.Cache_op_D_IVAC    -> Sail_impl_base.Cache_op_D_IVAC
  | Sail2_instr_kinds.Cache_op_D_ISW     -> Sail_impl_base.Cache_op_D_ISW
  | Sail2_instr_kinds.Cache_op_D_CSW     -> Sail_impl_base.Cache_op_D_CSW
  | Sail2_instr_kinds.Cache_op_D_CISW    -> Sail_impl_base.Cache_op_D_CISW
  | Sail2_instr_kinds.Cache_op_D_ZVA     -> Sail_impl_base.Cache_op_D_ZVA
  | Sail2_instr_kinds.Cache_op_D_CVAC    -> Sail_impl_base.Cache_op_D_CVAC
  | Sail2_instr_kinds.Cache_op_D_CVAU    -> Sail_impl_base.Cache_op_D_CVAU
  | Sail2_instr_kinds.Cache_op_D_CIVAC   -> Sail_impl_base.Cache_op_D_CIVAC
  | Sail2_instr_kinds.Cache_op_I_IALLUIS -> Sail_impl_base.Cache_op_I_IALLUIS
  | Sail2_instr_kinds.Cache_op_I_IALLU   -> Sail_impl_base.Cache_op_I_IALLU
  | Sail2_instr_kinds.Cache_op_I_IVAU    -> Sail_impl_base.Cache_op_I_IVAU
  end

let sail2_ik_to_sail1 ik =
  match ik with
  | Sail2_instr_kinds.IK_barrier bk       -> Sail_impl_base.IK_barrier (riscv_bk_to_sail1 bk)
  | Sail2_instr_kinds.IK_mem_read rk      -> Sail_impl_base.IK_mem_read (riscv_rk_to_sail1 rk)
  | Sail2_instr_kinds.IK_mem_write wk     -> Sail_impl_base.IK_mem_write (riscv_wk_to_sail1 wk)
  | Sail2_instr_kinds.IK_mem_rmw (rk, wk) -> Sail_impl_base.IK_mem_rmw (riscv_rk_to_sail1 rk, riscv_wk_to_sail1 wk)
  | Sail2_instr_kinds.IK_branch ()        -> Sail_impl_base.IK_branch
  | Sail2_instr_kinds.IK_trans tk         -> Sail_impl_base.IK_trans (riscv_tk_to_sail1 tk)
  | Sail2_instr_kinds.IK_simple ()        -> Sail_impl_base.IK_simple
  | Sail2_instr_kinds.IK_cache_op ck      -> Sail_impl_base.IK_cache_op (riscv_ck_to_sail1 ck)
  end

let bool_from_bitl b =
  match b with
  | Bitl_zero    -> false
  | Bitl_one     -> true
  | Bitl_undef   -> false
  | Bitl_unknown -> false
  end

let riscv_regfp_to_sail1 rfp =
  match rfp with
  | Riscv_types.RFull s     -> Sail_values.RFull s
  | Riscv_types.RSlice t    -> Sail_values.RSlice t
  | Riscv_types.RSliceBit t -> Sail_values.RSliceBit t
  | Riscv_types.RField t    -> Sail_values.RField t
  end

let riscv_niafp_to_sail1 nfp =
  match nfp with
  | Riscv_types.NIAFP_successor ()        -> Sail_values.NIAFP_successor
  | Riscv_types.NIAFP_indirect_address () -> Sail_values.NIAFP_indirect_address
  | Riscv_types.NIAFP_concrete_address bv -> Sail_values.NIAFP_concrete_address (riscv_bits_to_sail1_vec bv)
  end

let riscv_diafp_to_sail1 dfp =
  match dfp with
  | Riscv_types.DIAFP_none ()     -> Sail_values.DIAFP_none
  | Riscv_types.DIAFP_concrete bv -> Sail_values.DIAFP_concrete (riscv_bits_to_sail1_vec bv)
  | Riscv_types.DIAFP_reg rfp     -> Sail_values.DIAFP_reg (riscv_regfp_to_sail1 rfp)
  end

let armv8_regfp_to_sail1 rfp =
  match rfp with
  | ArmV8_types.RFull s     -> Sail_values.RFull s
  | ArmV8_types.RSlice t    -> Sail_values.RSlice t
  | ArmV8_types.RSliceBit t -> Sail_values.RSliceBit t
  | ArmV8_types.RField t    -> Sail_values.RField t
  end

let armv8_niafp_to_sail1 nfp =
  match nfp with
  | ArmV8_types.NIAFP_successor ()        -> Sail_values.NIAFP_successor
  | ArmV8_types.NIAFP_indirect_address () -> Sail_values.NIAFP_indirect_address
  | ArmV8_types.NIAFP_concrete_address bv -> Sail_values.NIAFP_concrete_address (armv8_bits_to_sail1_vec bv)
  end

let armv8_diafp_to_sail1 dfp =
  match dfp with
  | ArmV8_types.DIAFP_none ()     -> Sail_values.DIAFP_none
  | ArmV8_types.DIAFP_concrete bv -> Sail_values.DIAFP_concrete (armv8_bits_to_sail1_vec bv)
  | ArmV8_types.DIAFP_reg rfp     -> Sail_values.DIAFP_reg (armv8_regfp_to_sail1 rfp)
  end

   
let outcome_unwrap o =
  match o with
  | Sail_impl_base.Done a -> a
  | _ -> failwith "outcome_unwrap given non-Done"
  end


let riscv_string_to_sail1_reg name =
  let len = match name with
    | "cur_privilege" -> 2
    | "medeleg"       -> 65
    | "sedeleg"       -> 66
    | "misa"          -> 67
    | "mtvec"         -> 68
    | "mideleg"       -> 69
    | "mie"           -> 69
    | "mip"           -> 69
    | "mstatus"       -> 70
    (* | "sstatus"       -> 71 *)
    | "mcause"        -> 72
    | "scause"        -> 72

    | _               -> 64
    end in
  Sail_impl_base.Reg name (len - 1) len Sail_impl_base.D_decreasing

(* Extremely hacky. Chooses what riscv type is wanted based on the length of the register... *)
let sail1_regval_to_riscv rv =
  if rv.rv_start <> 0 || rv.rv_dir <> Sail_impl_base.D_decreasing then failwith "invalid vector sail1_regval_to_riscv" else
    match List.length (rv.rv_bits) with
    | 1 ->
       Riscv_types.Regval_bool (bool_from_bitl (List_extra.head rv.rv_bits))
    | 2 ->
       Riscv_types.Regval_Privilege (Riscv.privLevel_of_bits (Machine_word.wordFromBitlist (List.map bool_from_bitl rv.rv_bits)))
    | 64 ->
       Riscv_types.Regval_vector_64_dec_bit (Machine_word.wordFromBitlist (List.map bool_from_bitl rv.rv_bits))
    | 65 ->
       Riscv_types.Regval_Medeleg <| Riscv_types.Medeleg_Medeleg_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 1 rv.rv_bits))) |>
    | 66 ->
       Riscv_types.Regval_Sedeleg <| Riscv_types.Sedeleg_Sedeleg_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 2 rv.rv_bits))) |>
    | 67 ->
       Riscv_types.Regval_Misa <| Riscv_types.Misa_Misa_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 3 rv.rv_bits))) |>
    | 68 ->
       Riscv_types.Regval_Mtvec <| Riscv_types.Mtvec_Mtvec_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 4 rv.rv_bits))) |>
    | 69 ->
       Riscv_types.Regval_Minterrupts <| Riscv_types.Minterrupts_Minterrupts_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 5 rv.rv_bits))) |>
    | 70 ->
       Riscv_types.Regval_Mstatus <| Riscv_types.Mstatus_Mstatus_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 6 rv.rv_bits))) |>
    (* | 71 ->
     *    Riscv_types.Regval_Sstatus <| Riscv_types.Sstatus_Sstatus_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 7 rv.rv_bits))) |> *)
    | 72 ->
       Riscv_types.Regval_Mcause <| Riscv_types.Mcause_Mcause_chunk_0 = (Machine_word.wordFromBitlist (List.map bool_from_bitl (List.drop 8 rv.rv_bits))) |>

    | _ ->
       failwith "invalid vector length given to sail1_regval_to_riscv"
    end

let bl0 = Bitl_zero

let riscv_regval_to_sail rv =
  match rv with
  | Riscv_types.Regval_bool b              -> build_register_value [bool_to_bitl b] D_decreasing 1 0
  | Riscv_types.Regval_Privilege p         -> build_register_value (List.map bool_to_bitl (Machine_word.bitlistFromWord (Riscv.privLevel_to_bits p))) D_decreasing 2 1
  | Riscv_types.Regval_Medeleg <| Riscv_types.Medeleg_Medeleg_chunk_0 = w |> -> build_register_value (bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 65 64
  | Riscv_types.Regval_Sedeleg <| Riscv_types.Sedeleg_Sedeleg_chunk_0 = w |> -> build_register_value (bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 66 65
  | Riscv_types.Regval_Misa <| Riscv_types.Misa_Misa_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 67 66
  | Riscv_types.Regval_Mtvec <| Riscv_types.Mtvec_Mtvec_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 68 67
  | Riscv_types.Regval_Minterrupts <| Riscv_types.Minterrupts_Minterrupts_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 69 68
  | Riscv_types.Regval_Mstatus <| Riscv_types.Mstatus_Mstatus_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 70 69
  (* | Riscv_types.Regval_Sstatus <| Riscv_types.Sstatus_Sstatus_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 71 70 *)
  | Riscv_types.Regval_Mcause <| Riscv_types.Mcause_Mcause_chunk_0 = w |> -> build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map bool_to_bitl (Machine_word.bitlistFromWord w))) D_decreasing 72 71

  | Riscv_types.Regval_vector_64_dec_bit w -> build_register_value (List.map bool_to_bitl (Machine_word.bitlistFromWord w)) D_decreasing 64 63
  | _ -> failwith "unknown regval given to riscv_regval_to_sail"
end

let armv8_string_to_sail1_reg name =
  let len = match name with
    | "PSTATE_nRW" -> 1
    | "PSTATE_E" -> 1

    | "PSTATE_M" -> 5

    | "TxNestingLevel" -> 8

    (* 32-bit bitfields *)
    | "CurrentEL" -> 33 (* CurrentEL_type *)
    | "DAIF" -> 34 (* DAIF_type *)
    | "NZCV" -> 35 (* NZCV_type *)
    | "SPSel" -> 36 (* SPSel_type *)
    | "SPSR_EL1" -> 37 (* SPSR_type *)
    | "SPSR_EL2" -> 37
    | "SPSR_EL3" -> 37
    | "SCR" -> 38 (* SCRType *)
    | "SCR_EL3" -> 38
    | "DBGOSDLR" -> 39 (* DBGOSDLR_type *)
    | "DBGPRCR" -> 40 (* DBGPRCR_type *)
    | "DBGPRCR_EL1" -> 40 
    | "SCTLR_EL1" -> 41 (* SCTLR_EL1_type *)
    | "SCTLR_EL2" -> 42 (* SCTLR_type *)
    | "SCTLR_EL3" -> 42
    | "TCR_EL2" -> 43 (* TCR_type *)
    | "TCR_EL3" -> 43
    | "OSDLR_EL1" -> 45 (* OSDLR_type *)
    | "EDSCR" -> 46 (* EDSCR_type *)

    | "R0"-> 64
    | "R1"-> 64
    | "R2"-> 64
    | "R3"-> 64
    | "R4"-> 64
    | "R5"-> 64
    | "R6"-> 64
    | "R7"-> 64
    | "R8"-> 64
    | "R9"-> 64
    | "R10"-> 64
    | "R11"-> 64
    | "R12"-> 64
    | "R13"-> 64
    | "R14"-> 64
    | "R15"-> 64
    | "R16"-> 64
    | "R17"-> 64
    | "R18"-> 64
    | "R19"-> 64
    | "R20"-> 64
    | "R21"-> 64
    | "R22"-> 64
    | "R23"-> 64
    | "R24"-> 64
    | "R25"-> 64
    | "R26"-> 64
    | "R27"-> 64
    | "R28"-> 64
    | "R29"-> 64
    | "R30" -> 64
    | "SP_EL0" -> 64
    | "SP_EL1" -> 64
    | "SP_EL2" -> 64
    | "SP_EL3" -> 64
    | "ELR_EL1" -> 64
    | "ELR_EL2" -> 64
    | "ELR_EL3" -> 64
    | "RVBAR_EL1" -> 64
    | "RVBAR_EL2" -> 64
    | "RVBAR_EL3" -> 64
    | "TPIDR_EL0" -> 64
    | "TPIDR_EL1" -> 64
    | "TPIDR_EL2" -> 64
    | "TPIDR_EL3" -> 64
    | "_PC" -> 64
    | "data_cache_operation_CVAU" -> 64
    | "instruction_cache_operation_IVAU" -> 64

    (* 64-bit bitfields *)
    | "TMAbortEffect" -> 65 (* TMSTATUS_type *)
    | "TMStartEffect" -> 65
    | "HCR_EL2" -> 66 (* HCR_type *)
    | "ID_AA64MMFR0_EL1" -> 67 (* ID_AA64MMFR0_type *)
    | "TCR_EL1" -> 68 (* TCR_EL1_type *)
    | "TXIDR_EL0" -> 69 (* TXIDR_EL0_type *)

    | "V0"-> 128
    | "V1"-> 128
    | "V2"-> 128
    | "V3"-> 128
    | "V4"-> 128
    | "V5"-> 128
    | "V6"-> 128
    | "V7"-> 128
    | "V8"-> 128
    | "V9"-> 128
    | "V10"-> 128
    | "V11"-> 128
    | "V12"-> 128
    | "V13"-> 128
    | "V14"-> 128
    | "V15"-> 128
    | "V16"-> 128
    | "V17"-> 128
    | "V18"-> 128
    | "V19"-> 128
    | "V20"-> 128
    | "V21"-> 128
    | "V22"-> 128
    | "V23"-> 128
    | "V24"-> 128
    | "V25"-> 128
    | "V26"-> 128
    | "V27"-> 128
    | "V28"-> 128
    | "V29"-> 128
    | "V30" -> 128
    | "V31" -> 128
    | _ -> failwith ("unknown register " ^ name ^ " in armv8_string_to_sail1_reg")
    end in
  Sail_impl_base.Reg name (len - 1) len Sail_impl_base.D_decreasing

let sail1_regval_to_armv8 rv =
  let _ = debug_print "in sail1_regval_to_armv8" in
  if rv.rv_start <> 0 || rv.rv_dir <> Sail_impl_base.D_decreasing then failwith "invalid vector sail1_regval_to_armv8" else
    match List.length (rv.rv_bits) with
    | 1 ->
       ArmV8_types.regval_of_vector (fun v -> ArmV8_types.regval_of_bit v) 1 false (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) rv.rv_bits)
    | 5 ->
       ArmV8_types.regval_of_vector (fun v -> ArmV8_types.regval_of_bit v) 5 false (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) rv.rv_bits)
    | 8 ->
       ArmV8_types.regval_of_vector (fun v -> ArmV8_types.regval_of_bit v) 8 false (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) rv.rv_bits)
    | 64 ->
       ArmV8_types.regval_of_vector (fun v -> ArmV8_types.regval_of_bit v) 64 false (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) rv.rv_bits)
    | 128 ->
       ArmV8_types.regval_of_vector (fun v -> ArmV8_types.regval_of_bit v) 128 false (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) rv.rv_bits)

    (* 32-bit bitfields *)
    | 33 ->
       ArmV8_types.Regval_CurrentEL_type <| ArmV8_types.CurrentEL_type_CurrentEL_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 1 rv.rv_bits)) |>
    | 34 ->
       ArmV8_types.Regval_DAIF_type <| ArmV8_types.DAIF_type_DAIF_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 2 rv.rv_bits)) |>
    | 35 ->
       ArmV8_types.Regval_NZCV_type <| ArmV8_types.NZCV_type_NZCV_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 3 rv.rv_bits)) |>
    | 36 ->
       ArmV8_types.Regval_SPSel_type <| ArmV8_types.SPSel_type_SPSel_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 4 rv.rv_bits)) |>
    | 37 ->
       ArmV8_types.Regval_SPSR_type <| ArmV8_types.SPSR_type_SPSR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 5 rv.rv_bits)) |>
    | 38 ->
       ArmV8_types.Regval_SCRType <| ArmV8_types.SCRType_SCRType_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 6 rv.rv_bits)) |>
    | 39 ->
       ArmV8_types.Regval_DBGOSDLR_type <| ArmV8_types.DBGOSDLR_type_DBGOSDLR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 7 rv.rv_bits)) |>
    | 40 ->
       ArmV8_types.Regval_DBGPRCR_type <| ArmV8_types.DBGPRCR_type_DBGPRCR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 8 rv.rv_bits)) |>
    | 41 ->
       ArmV8_types.Regval_SCTLR_EL1_type <| ArmV8_types.SCTLR_EL1_type_SCTLR_EL1_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 9 rv.rv_bits)) |>
    | 42 ->
       ArmV8_types.Regval_SCTLR_type <| ArmV8_types.SCTLR_type_SCTLR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 10 rv.rv_bits)) |>
    | 43 ->
       ArmV8_types.Regval_TCR_type <| ArmV8_types.TCR_type_TCR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 11 rv.rv_bits)) |>
    | 45 ->
       ArmV8_types.Regval_OSDLR_type <| ArmV8_types.OSDLR_type_OSDLR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 13 rv.rv_bits)) |>
    | 46 ->
       ArmV8_types.Regval_EDSCR_type <| ArmV8_types.EDSCR_type_EDSCR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 14 rv.rv_bits)) |>

    (* 64-bit bitfields *)
    | 65 ->
       ArmV8_types.Regval_TMSTATUS_type <| ArmV8_types.TMSTATUS_type_TMSTATUS_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 1 rv.rv_bits)) |>
    | 66 ->
       ArmV8_types.Regval_HCR_type <| ArmV8_types.HCR_type_HCR_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 2 rv.rv_bits)) |>
    | 67 ->
       ArmV8_types.Regval_ID_AA64MMFR0_type <| ArmV8_types.ID_AA64MMFR0_type_ID_AA64MMFR0_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 3 rv.rv_bits)) |>
    | 68 ->
       ArmV8_types.Regval_TCR_EL1_type <| ArmV8_types.TCR_EL1_type_TCR_EL1_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 4 rv.rv_bits)) |>
    | 69 ->
       ArmV8_types.Regval_TXIDR_EL0_type <| ArmV8_types.TXIDR_EL0_type_TXIDR_EL0_type_chunk_0 = (List.map (fun b -> sail_bit_1to2 (bitU_of_bitl b)) (List.drop 5 rv.rv_bits)) |>

    | _ ->
       failwith "invalid vector length given to sail1_regval_to_armv8"
end

let armv8_regval_to_sail rv =
  match rv with
  | ArmV8_types.Regval_vector (len, false, vs) ->
     (* why doesn't lem let me pattern match on integers like I want *)
     if len = 1 then
       build_register_value (List.map (fun (ArmV8_types.Regval_bit b) -> bitl_of_bitU (sail_bit_2to1 b)) vs) D_decreasing 1 0
     else if len = 5 then
       build_register_value (List.map (fun (ArmV8_types.Regval_bit b) -> bitl_of_bitU (sail_bit_2to1 b)) vs) D_decreasing 5 4
     else if len = 8 then
       build_register_value (List.map (fun (ArmV8_types.Regval_bit b) -> bitl_of_bitU (sail_bit_2to1 b)) vs) D_decreasing 8 7
     else if len = 64 then
       build_register_value (List.map (fun (ArmV8_types.Regval_bit b) -> bitl_of_bitU (sail_bit_2to1 b)) vs) D_decreasing 64 63
     else if len = 128 then
       build_register_value (List.map (fun (ArmV8_types.Regval_bit b) -> bitl_of_bitU (sail_bit_2to1 b)) vs) D_decreasing 128 127
     else
       failwith "invalid vector length given to armv8_regval_to_sail"

  (* 32-bit bitfields *)
  | ArmV8_types.Regval_CurrentEL_type <| ArmV8_types.CurrentEL_type_CurrentEL_type_chunk_0 = bits |> ->
     build_register_value (bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 33 32
  | ArmV8_types.Regval_DAIF_type <| ArmV8_types.DAIF_type_DAIF_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 34 33
  | ArmV8_types.Regval_NZCV_type <| ArmV8_types.NZCV_type_NZCV_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 35 34
  | ArmV8_types.Regval_SPSel_type <| ArmV8_types.SPSel_type_SPSel_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 36 35
  | ArmV8_types.Regval_SPSR_type <| ArmV8_types.SPSR_type_SPSR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 37 36
  | ArmV8_types.Regval_SCRType <| ArmV8_types.SCRType_SCRType_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 38 37
  | ArmV8_types.Regval_DBGOSDLR_type <| ArmV8_types.DBGOSDLR_type_DBGOSDLR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 39 38
  | ArmV8_types.Regval_DBGPRCR_type <| ArmV8_types.DBGPRCR_type_DBGPRCR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 40 39
  | ArmV8_types.Regval_SCTLR_EL1_type <| ArmV8_types.SCTLR_EL1_type_SCTLR_EL1_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 41 40
  | ArmV8_types.Regval_SCTLR_type <| ArmV8_types.SCTLR_type_SCTLR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 42 41
  | ArmV8_types.Regval_TCR_type <| ArmV8_types.TCR_type_TCR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 43 42
  | ArmV8_types.Regval_OSDLR_type <| ArmV8_types.OSDLR_type_OSDLR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 45 44
  | ArmV8_types.Regval_EDSCR_type <| ArmV8_types.EDSCR_type_EDSCR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 46 45

  (* 64-bit bitfields *)
  | ArmV8_types.Regval_TMSTATUS_type <| ArmV8_types.TMSTATUS_type_TMSTATUS_type_chunk_0 = bits |> ->
     build_register_value (bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 65 64
  | ArmV8_types.Regval_HCR_type <| ArmV8_types.HCR_type_HCR_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 66 65
  | ArmV8_types.Regval_ID_AA64MMFR0_type <| ArmV8_types.ID_AA64MMFR0_type_ID_AA64MMFR0_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 67 66
  | ArmV8_types.Regval_TCR_EL1_type <| ArmV8_types.TCR_EL1_type_TCR_EL1_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 68 67
  | ArmV8_types.Regval_TXIDR_EL0_type <| ArmV8_types.TXIDR_EL0_type_TXIDR_EL0_type_chunk_0 = bits |> ->
     build_register_value (bl0::bl0::bl0::bl0::bl0::(List.map (fun b -> bitl_of_bitU (sail_bit_2to1 b)) bits)) D_decreasing 69 68
    
  | _ ->
     failwith "invalid regval given to armv8_regval_to_sail"
  end

let address_lifted_of_address a =
  match a with
    Address bytes i -> Address_lifted (List.map byte_lifted_of_byte bytes) (Just i)
  end

let sail2_addr_to_sail1 addr = address_lifted_of_address (address_of_integer (integerFromNat addr))

val sail1_memval_to_sail2 : memory_value -> list Sail2_values.memory_byte
let sail1_memval_to_sail2 mv =
  let integer = (match (integer_of_memory_value E_big_endian mv) with | Just x -> x | Nothing -> failwith "integer_of_memory_value failed in sail1_memval_to_sail2" end) in
  let len = 8 * (integerFromNat (memory_value_length mv)) in
  let bits = (Sail2_values.bits_of_int len integer) in
  match (Sail2_values.bytes_of_bits bits) with | Just x -> x | Nothing -> failwith "bytes_of_bits failed in sail1_memval_to_sail2" end

let sail2_memval_to_sail1 mv =
  let len = List.length mv in
  memory_value_of_integer E_big_endian len (fromJust (Sail2_values.unsigned_of_bits (Sail2_values.bits_of_bytes mv)))

(* TODO FIXME expand and correct *)
val riscv_prompt_to_outcome : forall 'a 'e. Sail2_prompt_monad.monad Riscv_types.register_value 'a 'e -> outcome 'a
let rec riscv_prompt_to_outcome p =
  match p with
  | Sail2_prompt_monad.Done a                 -> Sail_impl_base.Done a
  | Sail2_prompt_monad.Exception e            -> Sail_impl_base.Fail (Just "*Sail2 exception escaped*") (* TODO *)
  | Sail2_prompt_monad.Fail s                 -> Sail_impl_base.Fail (Just s)
  | Sail2_prompt_monad.Print s next           -> riscv_prompt_to_outcome next (* TODO *)
  | Sail2_prompt_monad.Footprint next         -> Sail_impl_base.Footprint (riscv_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Choose _ _             -> failwith "unsupported Choose constructor of prompt monad"
  | Sail2_prompt_monad.Read_memt _ _ _ _      -> failwith "unsupported Read_memt constructor of prompt monad"
  | Sail2_prompt_monad.Write_memt _ _ _ _ _ _ -> failwith "unsupported Write_memt constructor of prompt monad"
  | Sail2_prompt_monad.Read_reg name f        -> Sail_impl_base.Read_reg (riscv_string_to_sail1_reg name) (fun v -> (riscv_prompt_to_outcome (f (sail1_regval_to_riscv v)), Nothing))
  | Sail2_prompt_monad.Write_reg name v next  -> Sail_impl_base.Write_reg (riscv_string_to_sail1_reg name, riscv_regval_to_sail v) (riscv_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Barrier bk next        -> Sail_impl_base.Barrier (riscv_bk_to_sail1 bk) (riscv_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Read_mem rk a sz f     -> Sail_impl_base.Read_mem (riscv_rk_to_sail1 rk, sail2_addr_to_sail1 a, sz) (fun mv -> (riscv_prompt_to_outcome (f (sail1_memval_to_sail2 mv)), Nothing))
  | Sail2_prompt_monad.Write_ea wk a sz next  -> Sail_impl_base.Write_ea (riscv_wk_to_sail1 wk, sail2_addr_to_sail1 a, sz) (riscv_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Write_mem _ _ _ mv f   -> Sail_impl_base.Write_memv (sail2_memval_to_sail1 mv) (fun b -> (riscv_prompt_to_outcome (f b), Nothing))
  | Sail2_prompt_monad.Excl_res f             -> Sail_impl_base.Excl_res (fun b -> (riscv_prompt_to_outcome (f b), Nothing))
end

(* TODO FIXME expand and correct *)
val armv8_prompt_to_outcome : forall 'a 'e. Sail2_prompt_monad.monad ArmV8_types.register_value 'a 'e -> outcome 'a
let rec armv8_prompt_to_outcome p =
  match p with
  | Sail2_prompt_monad.Done a                 -> Sail_impl_base.Done a
  | Sail2_prompt_monad.Exception e            -> Sail_impl_base.Fail (Just "*Sail2 exception escaped*") (* TODO *)
  | Sail2_prompt_monad.Fail s                 -> Sail_impl_base.Fail (Just s)
  | Sail2_prompt_monad.Print s next           -> armv8_prompt_to_outcome next (* TODO *)
  | Sail2_prompt_monad.Footprint next         -> Sail_impl_base.Footprint (armv8_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Choose _ _             -> failwith "unsupported Choose constructor of prompt monad"
  | Sail2_prompt_monad.Read_memt _ _ _ _      -> failwith "unsupported Read_memt constructor of prompt monad"
  | Sail2_prompt_monad.Write_memt _ _ _ _ _ _ -> failwith "unsupported Write_memt constructor of prompt monad"
  | Sail2_prompt_monad.Read_reg name f        -> Sail_impl_base.Read_reg (armv8_string_to_sail1_reg name) (fun v -> (armv8_prompt_to_outcome (f (sail1_regval_to_armv8 v)), Nothing))
  | Sail2_prompt_monad.Write_reg name v next  -> Sail_impl_base.Write_reg (armv8_string_to_sail1_reg name, armv8_regval_to_sail v) (armv8_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Barrier bk next        -> Sail_impl_base.Barrier (riscv_bk_to_sail1 bk) (armv8_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Read_mem rk a sz f     -> Sail_impl_base.Read_mem (riscv_rk_to_sail1 rk, sail2_addr_to_sail1 a, sz) (fun mv -> (armv8_prompt_to_outcome (f (sail1_memval_to_sail2 mv)), Nothing))
  | Sail2_prompt_monad.Write_ea wk a sz next  -> Sail_impl_base.Write_ea (riscv_wk_to_sail1 wk, sail2_addr_to_sail1 a, sz) (armv8_prompt_to_outcome next, Nothing)
  | Sail2_prompt_monad.Write_mem _ _ _ mv f   -> Sail_impl_base.Write_memv (sail2_memval_to_sail1 mv) (fun b -> (armv8_prompt_to_outcome (f b), Nothing))
  | Sail2_prompt_monad.Excl_res f             -> Sail_impl_base.Excl_res (fun b -> (armv8_prompt_to_outcome (f b), Nothing))
end
   
val outcome_bind : forall 'a 'b. Sail_impl_base.outcome 'a -> ('a -> Sail_impl_base.outcome 'b) -> Sail_impl_base.outcome 'b
let rec outcome_bind o f =
  match o with
  | Sail_impl_base.Done a -> f a
  | Sail_impl_base.Read_mem x g -> Sail_impl_base.Read_mem x (fun m -> let (o', aux) = (g m) in (outcome_bind o' f, aux))
  | Sail_impl_base.Write_ea x owa' -> Sail_impl_base.Write_ea x (let (o', aux) = owa' in (outcome_bind o' f, aux))
  | Sail_impl_base.Excl_res g -> Sail_impl_base.Excl_res (fun b -> let (o', aux) = (g b) in (outcome_bind o' f, aux))
  | Sail_impl_base.Write_memv v g -> Sail_impl_base.Write_memv v (fun b -> let (o', aux) = (g b) in (outcome_bind o' f, aux))
  | Sail_impl_base.Barrier k owa' -> Sail_impl_base.Barrier k (let (o', aux) = owa' in (outcome_bind o' f, aux))
  | Sail_impl_base.Footprint owa' -> Sail_impl_base.Footprint (let (o', aux) = owa' in (outcome_bind o' f, aux))
  | Sail_impl_base.Read_reg r g -> Sail_impl_base.Read_reg r (fun v -> let (o', aux) = (g v) in (outcome_bind o' f, aux))
  | Sail_impl_base.Write_reg (r, v) owa' -> Sail_impl_base.Write_reg (r, v) (let (o', aux) = owa' in (outcome_bind o' f, aux))
  | Sail_impl_base.Internal h owa' -> Sail_impl_base.Internal h (let (o', aux) = owa' in (outcome_bind o' f, aux))
  | Sail_impl_base.Escape s -> Sail_impl_base.Escape s
  | Sail_impl_base.Fail s -> Sail_impl_base.Fail s
  | Sail_impl_base.Error s -> Sail_impl_base.Error s
  end
   
let ignore_outcome o = outcome_bind o (fun _ -> Sail_impl_base.Done ())

let analysis_outcome_riscv_to_sail1 o =
  outcome_bind o
    (fun (input_regs,output_regs,address_feeding_address_regs,nias,dia,instruction_kind) ->
      Sail_impl_base.Done
        (List.map riscv_regfp_to_sail1 input_regs,
         List.map riscv_regfp_to_sail1 output_regs,
         List.map riscv_regfp_to_sail1 address_feeding_address_regs,
         List.map riscv_niafp_to_sail1 nias,
         riscv_diafp_to_sail1 dia,
         sail2_ik_to_sail1 instruction_kind)
    )

let analysis_outcome_armv8_to_sail1 o =
  outcome_bind o
    (fun (input_regs,output_regs,address_feeding_address_regs,nias,dia,instruction_kind) ->
      Sail_impl_base.Done
        (List.map armv8_regfp_to_sail1 input_regs,
         List.map armv8_regfp_to_sail1 output_regs,
         List.map armv8_regfp_to_sail1 address_feeding_address_regs,
         List.map armv8_niafp_to_sail1 nias,
         armv8_diafp_to_sail1 dia,
         sail2_ik_to_sail1 instruction_kind)
    )

(** shallow embedding ***********************************************)

val handle_reg_reads : forall 'a. list (reg_name * register_value) -> outcome 'a -> 'a
let rec handle_reg_reads environment outcome =
  match outcome with
  | Read_reg reg_name c ->
     let regval =
       ensure_just (List.lookup reg_name environment)
                   ("no value in environment for register " ^ show reg_name ^ " in list [" ^ (String.concat ", " (List.map show (List.map fst environment))) ^ "]") in
     handle_reg_reads environment (fst (c regval))
  | Fail (Just err) -> failwith ("handle_reads: Fail " ^ err)
  | Fail Nothing -> failwith ("handle_reads: Fail with unspecified error")
  | Error string -> failwith ("handle_reads: Error " ^ string)
  | Done v -> v
  | _ -> failwith "handle_reg_reads: unhandled effect"
  end

let initialise_shallow_embedding_semantics endianness ism =
    let default_direction = match ism with
      | PPCGEN_ism -> true
      | AARCH64_ism AArch64HandSail -> false
      | AARCH64_ism AArch64GenSail -> false
      | MIPS_ism -> false
      | RISCV_ism -> false
      | X86_ism -> false
    end in

  let shallow_embedding__decode_to_instruction (address : address) (opcode : opcode) =
    let opcode_bitv =
      let (Opcode bytes) = opcode in
      bitv_of_bytes default_direction bytes in
    match ism with
    | PPCGEN_ism ->
       match Power_embed.decode opcode_bitv with
       | Nothing -> FDO_decode_error (Not_an_instruction_error opcode)
       | Just instr ->
          match Power_embed.supported_instructions instr with
          | Nothing -> FDO_decode_error(Unsupported_instruction_error opcode (PPCGEN_instr instr))
          | Just _ ->  FDO_success address (Just opcode) (PPCGEN_instr instr)
          end
       end
    | AARCH64_ism AArch64HandSail ->
       match ArmV8.decode (sail_bv_1to2 opcode_bitv) with
       | Sail2_prompt_monad.Done Nothing       -> FDO_decode_error (Not_an_instruction_error opcode)
       | Sail2_prompt_monad.Done (Just instr)  -> FDO_success address (Just opcode) (AArch64_instr instr)
       (* | Sail2_prompt_monad.Error descr         -> failwith ("armV8 decode failed with: Error " ^ descr)
        * | Sail2_prompt_monad.Fail (Just descr)   -> failwith ("armV8 decode failed with: Fail " ^ descr)
        * | Sail2_prompt_monad.Fail Nothing        -> failwith ("armV8 decode failed with unspecified error: Fail")
        * | Sail2_prompt_monad.Escape (Just descr) -> failwith ("armV8 decode failed with: Exception " ^ descr)
        * | Sail2_prompt_monad.Escape Nothing      -> failwith ("armV8 decode failed with exception: Exception")
        * | Sail2_prompt_monad.Internal _ _        -> failwith ("armV8 decode returned unexpected Internal outcome") *)
       | _                   -> failwith ("armV8 decode had unhandled effect")
       end
    | AARCH64_ism AArch64GenSail -> failwith "AArch64Gen ISA not supported by shallow embedding"
    | MIPS_ism ->
       match Mips_embed.decode opcode_bitv with
       | Nothing -> FDO_decode_error (Not_an_instruction_error opcode)
       | Just instr -> FDO_success address (Just opcode) (MIPS_instr instr)
       end
   | RISCV_ism ->
      let instr = Riscv.decode (Sail2_operators_mwords.vec_of_bits (sail_bv_1to2 opcode_bitv)) in
      FDO_success address (Just opcode) (RISCV_instr instr)
   | X86_ism ->
      failwith "x86 decode not implemented"
    end in

  let shallow_embedding__initial_outcome_s_of_instruction = function
    | PPCGEN_instr instr  ->  (Power_embed.execute instr,Nothing)
    | AArch64_instr instr ->  (ignore_outcome (armv8_prompt_to_outcome (ArmV8.execute instr)),Nothing)
    | MIPS_instr instr ->     (Mips_embed.execute instr,Nothing)
    | RISCV_instr instr ->    (ignore_outcome (riscv_prompt_to_outcome (Riscv.execute instr)),Nothing)
    | X86_instr instr ->      (X86_embed.execute instr,Nothing)
    | Fetch_error         -> failwith "initial_outcome_s_of_instruction Fetch_error"
    end in

  let shallow_embedding__instruction_analysis _ instr analysis_function reginfo _ environment =
    let (input_regs,output_regs,address_feeding_address_regs,nias,dia,instruction_kind) =
      (handle_reg_reads environment)
        match (instr, analysis_function) with
        | (PPCGEN_instr instr, "initial_analysis") ->
           Power_embed.initial_analysis instr
        | (PPCGEN_instr instr, "recalculate_lswx_reg_footprint") ->
           Power_embed.recalculate_lswx_reg_footprint instr
        | (PPCGEN_instr instr, "recalculate_stswx_reg_footprint") ->
           Power_embed.recalculate_stswx_reg_footprint instr
        | (PPCGEN_instr _, _) ->
           failwith "instruction_analysis: unknown POWER analysis function"
        | (AArch64_instr instr, "initial_analysis") ->
           analysis_outcome_armv8_to_sail1 (armv8_prompt_to_outcome (ArmV8.initial_analysis instr))
        | (AArch64_instr _, _) ->
           failwith "instruction_analysis: unknown ARM analysis function"
        | (MIPS_instr instr, "initial_analysis") ->
           Mips_embed.initial_analysis instr
        | (MIPS_instr _, _) ->
           failwith "instruction_analysis: unknown MIPS analysis function"
        | (RISCV_instr instr, "initial_analysis") ->
           analysis_outcome_riscv_to_sail1 (riscv_prompt_to_outcome (Riscv.initial_analysis instr))
        | (RISCV_instr _, _) ->
           failwith "instruction_analysis: unknown RISCV analysis function"
        | (X86_instr instr, "initial_analysis") ->
           X86_embed.initial_analysis instr
        | (X86_instr _, _) ->
           failwith "instruction_analysis: unknown X86 analysis function"
        | (Fetch_error,_) ->
           failwith "instruction_analysis: Fetch_error"
        end in
    let (input_regs,output_regs,address_feeding_address_regs,nias,dia,instruction_kind) =
      (List.map (regfp_to_reg reginfo) input_regs,
       List.map (regfp_to_reg reginfo) output_regs,
       List.map (regfp_to_reg reginfo) address_feeding_address_regs,
       List.map (niafp_to_nia reginfo) nias,
       diafp_to_dia reginfo dia,
       instruction_kind) in
    (input_regs,output_regs,address_feeding_address_regs,nias,dia,instruction_kind) in

    <| instruction_analysis = shallow_embedding__instruction_analysis;
       decode_to_instruction = shallow_embedding__decode_to_instruction;
       initial_outcome_s_of_instruction =
         shallow_embedding__initial_outcome_s_of_instruction |>


let interp_nias_of_instruction
    (instruction: instruction_ast)
    (nia_address: list (maybe address)) (* Nothing for unknown/undef *)
    : list nia
  =
  let nias = List.map
      function
      | Just a  -> NIA_concrete_address a
      | Nothing -> NIA_indirect_address
      end
      nia_address
  in

  (* it's a fact of the Power2.06B instruction pseudocode that in the B and Bc
     cases there should be no Unknown values in nia_values, while in the Bclr
     and Bcctr cases nia_values will just be Unknown and the semantics should
     match the comments in the machineDefTypes definition of nia *)

  (* the Sail code only writes to the nia register when a branch is taken,
  i.e., if the branch is not taken it will not explicitly writes PC+4;
  hence, for most instructions we need to add NIA_successor to 'nias' *)
  match instruction with
  | PPCGEN_instr (Power_embed_types.B _) ->
      let () = ensure
        (forall (nia MEM nias).
            match nia with
            | NIA_concrete_address _ -> true
            | _ -> false
            end)
        "unexpected unknown/undefined address in nia_values ('b' instruction)"
      in
      nias
  | PPCGEN_instr i ->
      let () = ensure
        ((exists (nia MEM nias). nia = NIA_indirect_address) -->
            match i with
            | Power_embed_types.Bclr _  -> true
                (* the indirect address is "LR0:61 || 0b00" in Power pseudocode *)
            | Power_embed_types.Bcctr _ -> true
                (* the indirect address is "CTR0:61 || 0b00" in Power pseudocode *)
            | _ -> false
            end)
        "unexpected unknown/undefined address in nia_values"
      in
      NIA_successor :: nias

  | AArch64_instr (ArmV8_types.BranchImmediate _) ->
      let () = ensure
        match nias with
        | NIA_concrete_address _ :: [] -> true
        | _ -> false
        end
        "unexpected nia_values ('BranchImmediate' instruction)"
      in
      nias
  | AArch64_instr (ArmV8_types.BranchRegister _) ->
      let () = ensure
        match nias with
        | _ :: [] -> true
            (* the nia will be NIA_concrete_address if the register is
            XZR, otherwise it will be NIA_indirect_address *)
        | _ -> false
        end
        "unexpected nia_values ('BranchImmediate' instruction)"
      in
      nias
  | AArch64_instr _ -> NIA_successor :: nias

  | MIPS_instr _ -> (* XXX TODO *)
      let () = ensure (nias = [])
        "unexpected address in nia_values" in
      NIA_successor :: []

  | RISCV_instr (Riscv_types.RISCV_JAL _) ->
      let () = ensure
        match nias with
        | NIA_concrete_address _ :: [] -> true
        | _ -> false
        end
        "unexpected nia_values ('BranchImmediate' instruction)"
      in
      nias
  | RISCV_instr (Riscv_types.RISCV_JALR _) ->
      let () = ensure
        match nias with
        | _ :: [] -> true
            (* the nia will be NIA_concrete_address if the register is
            x0, otherwise it will be NIA_indirect_address *)
        | _ -> false
        end
        "unexpected nia_values ('BranchImmediate' instruction)"
      in
      nias
  | RISCV_instr _ -> NIA_successor :: nias

  | X86_instr (X86_embed_types.Jcc _)  -> NIA_successor :: nias
  | X86_instr (X86_embed_types.LOOP _) -> NIA_successor :: nias
(* XXX  | X86_instr(X86_embed_types.CALL(_)) -> NIA_successor :: nias *)
(* XXX  | X86_instr(X86_embed_types.RET(_)) -> NIA_successor :: nias *)
(* XXX  | X86_instr(X86_embed_types.JMP(_)) -> NIA_successor :: nias *)
  | X86_instr _ ->
      let () = ensure (nias = [])
        "unexpected address in nia_values" in
      NIA_successor :: []

  | _ -> failwith "unexpected 'instruction' in interp_nias_of_instruction"
  end
