(*======================================================================================*)
(*                                                                                      *)
(*                rmem executable model                                                 *)
(*                =====================                                                 *)
(*                                                                                      *)
(*  This file is:                                                                       *)
(*                                                                                      *)
(*  Copyright Shaked Flur, University of Cambridge                          2015-2018   *)
(*  Copyright Christopher Pulte, University of Cambridge                    2016-2018   *)
(*  Copyright Peter Sewell, University of Cambridge                         2015-2016   *)
(*  Copyright Kathy Gray, University of Cambridge (when this work was done)      2015   *)
(*  Copyright Jon French, University of Cambridge                                2017   *)
(*                                                                                      *)
(*  All rights reserved.                                                                *)
(*                                                                                      *)
(*  It is part of the rmem tool, distributed under the 2-clause BSD licence in          *)
(*  LICENCE.txt.                                                                        *)
(*                                                                                      *)
(*======================================================================================*)

(* types to describe an axiomatic-model-like candidate execution *)

(* we're going to use this both for partial and complete executions,
in the interactive user interface and to draw completed-execution
figures (and potentially also for actual axiomatic model definitions)
*)

(*
- writes_read_from will be subsumed by the subreads data, but we need
  to remember the latter when leaving MOS_pending_mem_read

- the reg_reads data doesn't remember the instruction (or initial
  state) that it reads each slice from

- the initial register writes are handled in an awkward way, as a function

- do we want to record the success/fail of write-conditional?

- do we want to record whether reads are by forwarding? 

- what's aarch64_write_kind for?
*)

open import Sail_impl_base
open import Pervasives_extra
open import MachineDefTypes
open import MachineDefFreshIds
open import MachineDefEvents
open import MachineDefParams
open import MachineDefISAInfo
open import MachineDefInstructionSemantics
open import MachineDefFragments
open import MachineDefFlowingStorageSubsystem
open import MachineDefInstructionPredicates
open import MachineDefThreadSubsystemUtils
open import MachineDefThreadSubsystem
open import MachineDefSystem

val bigunionListMap : forall 'a 'b. SetType 'b => ('a -> set 'b) -> list 'a -> set 'b
let rec bigunionListMap f xs =
  match xs with
  | [] -> {}
  | x::xs' -> (f x) union bigunionListMap f xs'
  end


type cex_instruction_instance = 
    <| 
    cex_instance_ioid: ioid; 
    cex_program_loc: address;  
    cex_program_opcode: maybe opcode; 
    cex_instruction: instruction_ast;
    cex_instruction_kind: instruction_kind;
    (*cex_aarch64_write_kind: maybe write_kind;*)
    (* register part *)
    cex_regs_in: set reg_name;
    cex_regs_out: set reg_name;
    cex_regs_in_feeding_address: set reg_name;  
    cex_ioids_feeding_address: set ioid; (* these are the ioids of the
                                            instructions writing to
                                            cex_regs_in_feeding_address *)
    cex_reg_reads: list (reg_name * register_read_sources * register_value); (* accumulated register reads, most recent at head (possibly including pseudoregister reads)*)
    cex_reg_writes: list (reg_name * register_value); (* accumulated register writes, most recent at head (possibly including pseudoregister writes to NIA)*)
    (* memory part *)
    cex_writes_read_from: set (write*slices);  
    cex_committed_barriers: list barrier; 
    cex_potential_write_addresses: list write; 
    cex_potential_writes: list write; 
    cex_propagated_writes: list write;
    cex_requested_unsatisfied_reads: list (read_request);
    cex_satisfied_reads: list (read_request * memory_read_source);
    (* status *)
    cex_finished: bool;

    (* dependencies *)
    cex_address_dependencies: set ioid;
    cex_data_dependencies:    set ioid;
    cex_control_dependencies: set ioid;
  |>


type cex_instruction_tree =
  | CEX_T of list (cex_instruction_instance * cex_instruction_tree)

type cex_thread_state = 
    <| 
    cex_thread: thread_id;
    cex_register_data: registerdata;
    cex_initial_register_state: (reg_base_name -> register_value); (*TODO?*)
    cex_initial_fetch_address: maybe address;
    cex_instruction_tree: cex_instruction_tree;
  |>

type cex_candidate = 
    <| 
    cex_program_memory: (address -> fetch_and_decode_outcome);
    cex_initial_writes: list write;
    cex_threads: map thread_id cex_thread_state;
    cex_rf: Relation.rel (write * slices) read_request;
    cex_co: Relation.rel write write;
    cex_fr: Relation.rel read_request write;
    cex_model: model_params;
  |> 

let rec ioids_influencing_reg_reads_helper prefix ioid reg_names =
  match prefix with
  | [] -> {}
  | i :: prefix ->
      if i.instance_ioid = ioid then
        bigunionListMap
          (fun reg ->
            match List.lookup reg i.reg_writes with
            | Nothing -> failwith "missing register write"
            | Just (dependencies, _) ->
                bigunionListMap
                  (function
                  | RWD_reg_write ioid reg_names -> {ioid} union (ioids_influencing_reg_reads_helper prefix ioid reg_names)
                  | RWD_mem_read -> {}
                  end)
                  dependencies
            end
          )
          reg_names
      else ioids_influencing_reg_reads_helper prefix ioid reg_names
  end

let ioids_influencing_reg_reads
    (prefix:    list instruction_instance)
    (reg_reads: list (reg_name * register_read_sources * register_value))
    : set ioid
  =
  bigunionListMap
    (fun (_, register_read_sources, _) ->
      bigunionListMap
        (function
        | RRS_instruction ioid reg_names _ -> {ioid} union (ioids_influencing_reg_reads_helper prefix ioid reg_names)
        | RRS_initial_state _ -> {}
        | RRS_pseudoregister  -> {}
        end)
        register_read_sources
    )
    reg_reads

let rec find_control_dependencies prefix =
  match prefix with
  | [] -> {}
  | i :: prefix ->
      if is_cond_branch_instruction i || is_indirect_branch_instruction i then
        (* FIXME: should we add i.instance_ioid to the set? *)
        (ioids_influencing_reg_reads prefix i.reg_reads)
        union (find_control_dependencies prefix)
      else find_control_dependencies prefix
  end

let make_cex_instruction_instance
    (prefix: list instruction_instance)
    (i:      instruction_instance)
    : cex_instruction_instance
  =
  <|
    cex_instance_ioid = i.instance_ioid;
    cex_program_loc = i.program_loc;
    cex_program_opcode = i.program_opcode;
    cex_instruction = i.instruction; 
    cex_instruction_kind = i.instruction_kind;
    (* register part *)
    cex_regs_in = i.regs_in;
    cex_regs_out = i.regs_out;
    cex_regs_in_feeding_address = i.regs_in_feeding_address;
    cex_ioids_feeding_address = i.ioids_feeding_address;
    cex_reg_reads = i.reg_reads;
    cex_reg_writes = [(r, v) | forall ((r, (_, v)) MEM i.reg_writes) | true];
    (* memory part *)
    cex_writes_read_from =
      Set.fromList (List.concat (snd (List.unzip i.subreads.sr_writes_read_from)));
    cex_committed_barriers = i.committed_barriers;
    cex_potential_write_addresses = i.subwrites.sw_potential_write_addresses;
    cex_potential_writes = i.subwrites.sw_potential_writes;
    cex_propagated_writes = i.subwrites.sw_propagated_writes;
    cex_requested_unsatisfied_reads =
      List.mapMaybe
        (fun (rr, _) ->
          match List.lookup rr i.subreads.sr_unsat_slices with
          | Just [] -> Nothing (* request was already satisfied *)
          | Just _ -> Just rr
          | Nothing -> failwith "domain of sr_unsat_slices should include all read requests"
          end
        )
        i.subreads.sr_requested;
    cex_satisfied_reads =
      List.mapMaybe
        (fun (rr, writes_read_from) ->
            match List.lookup rr i.subreads.sr_unsat_slices with
            | Just [] ->
                let mrs =
                  <|  mrs_footprint        = rr.r_addr;
                      mrs_value            = value_of_write_slices writes_read_from;
                      mrs_writes_read_from = writes_read_from;
                  |>
                in
                Just (rr, mrs)
            | Just _ -> Nothing
            | Nothing -> failwith "domain of sr_unsat_slices should include all read requests"
            end
        )
        i.subreads.sr_writes_read_from;
    (* status *)
    cex_finished = i.finished;

    (* dependencies *)
    cex_address_dependencies =
      List.filter (fun (r, _, _) -> r IN i.regs_in_feeding_address) i.reg_reads
      $> ioids_influencing_reg_reads prefix;

    cex_data_dependencies =
      List.filter (fun (r, _, _) -> r NIN i.regs_in_feeding_address) i.reg_reads
      $> ioids_influencing_reg_reads prefix;

    cex_control_dependencies = find_control_dependencies prefix;
  |>


let rec entree_old (is: list instruction_instance) (it:cex_instruction_tree) : cex_instruction_tree =
  match is with
  | [] -> it
  | i::is' -> entree_old is' (CEX_T [(make_cex_instruction_instance is' i,it)])
  end

let rec make_cex_instruction_tree (prefix: list instruction_instance) (it:instruction_tree) : cex_instruction_tree =
  match it with
  | T iits -> 
      CEX_T (List.map (fun (i,it) -> (make_cex_instruction_instance prefix i, make_cex_instruction_tree (i :: prefix) it)) iits)
  end



let make_cex_thread_state tparams (thread_model : threadSubsystem 'ts) (t : 'ts) : cex_thread_state = 
    <| 
    cex_thread = thread_model.ts_tid t;
    cex_register_data = tparams.thread_isa_info.register_data_info;
    cex_initial_register_state = thread_model.ts_initial_reg_state t;
    cex_initial_fetch_address = thread_model.ts_initial_fetch_address t;
    cex_instruction_tree = 
      let (old_instructions,instruction_tree) = thread_model.ts_instruction_tree t in
      entree_old old_instructions (make_cex_instruction_tree old_instructions instruction_tree);
  |>

val make_cex_candidate : forall 'ts 'ss. system_state 'ts 'ss -> cex_candidate
let make_cex_candidate (s: system_state 'ts 'ss) : cex_candidate =
  let rf =
    let instructions =
      (Map.map (ts_instructions s.t_model) s.thread_states) $>
      Map.range $> Set.bigunion in
    Set.bigunionMap
      (fun i ->
        List.concatMap
          (fun (r, wss) -> [(ws, r) | forall (ws MEM wss) |true])
          i.subreads.sr_writes_read_from
        $> Set.fromList
      )
      instructions
  in


  let co = s.s_model.ss_coherence s.model.ss s.storage_subsystem in

  let fr =
    let rfConverse = {(r, w) | forall (((w, _), r) IN rf) | true} in
    Relation.relComp rfConverse co
    $> Set.filter (fun (r,w) -> non_empty_intersection r.r_addr w.w_addr)
  in

  <|
    cex_program_memory = s.program_memory;
    cex_initial_writes = s.initial_writes;
    cex_threads = Map.map (make_cex_thread_state s.model.t s.t_model) s.thread_states;
    cex_rf = rf;
    cex_co = Relation.withoutTransitiveEdges co;
    cex_fr = fr;
    cex_model = s.model;
  |> 


(** cutting down graphs to the concurrent accesses *)

let footprints_of_cex_instruction_instance (i:cex_instruction_instance) : set footprint =
  { w.w_addr | forall ((w,sls) IN  i.cex_writes_read_from) | true }
    union (Set.fromList [w.w_addr | forall (w MEM i.cex_potential_write_addresses) | true])
    union (Set.fromList [w.w_addr | forall (w MEM i.cex_potential_writes) | true])
    union (Set.fromList [w.w_addr | forall (w MEM i.cex_propagated_writes) | true])
    union (Set.fromList [r.r_addr | forall (r MEM i.cex_requested_unsatisfied_reads) | true])
    union (Set.fromList [r.r_addr | forall ((r,_) MEM i.cex_satisfied_reads) | true])

let rec footprints_of_cex_instruction_tree (it:cex_instruction_tree) : set footprint =
  match it with
  | CEX_T iits ->
     bigunionListMap 
        (fun (i,it) -> footprints_of_cex_instruction_instance i union footprints_of_cex_instruction_tree it) 
        iits
  end

let footprints_of_cex_thread_state (t:cex_thread_state) : set footprint =
  footprints_of_cex_instruction_tree t.cex_instruction_tree

let footprints_of_cex_candidate (cex:cex_candidate) : list (set footprint) =
  List.map (fun (tid,t)->footprints_of_cex_thread_state t) (Map_extra.toList cex.cex_threads)

let rec shared_memory_footprints_aux (acc: set footprint) (fpss: list (set footprint)) =
  match fpss with
  | [] -> acc
  | fps::fpss' ->
      let fp_shared : set footprint = 
        { fp | forall (fp IN fps) | exists (fps' MEM fpss'). exists (fp' IN fps'). MachineDefFragments.non_empty_intersection fp fp' } in
      shared_memory_footprints_aux (acc union fp_shared) fpss'
  end


let shared_memory_footprints (cex:cex_candidate) : set footprint = 
  let fpss = footprints_of_cex_candidate cex in
  shared_memory_footprints_aux {} fpss
  

let is_shared_memory_write (fp_shared: set footprint) (w: write) =
  MachineDefFragments.non_empty_intersection_set fp_shared { w.w_addr }

let is_shared_memory_read (fp_shared: set footprint) (r: read_request) =
  MachineDefFragments.non_empty_intersection_set fp_shared { r.r_addr }

let is_shared_memory_instruction (fp_shared: set footprint) (i: cex_instruction_instance) =
  match i.cex_instruction_kind with
  | IK_barrier _ -> true
  | _ -> false
  end
|| MachineDefFragments.non_empty_intersection_set fp_shared (footprints_of_cex_instruction_instance i)


let rec filter_instruction_tree (pi: cex_instruction_instance -> bool) (it: cex_instruction_tree) : cex_instruction_tree =
  match it with
  | CEX_T iits -> 
      CEX_T 
        (List.concatMap 
           (fun (i,it') ->
             let fit = filter_instruction_tree pi it' in
             if pi i then 
               [(i,fit)]
             else 
               match fit with CEX_T iits' -> iits' end
           ) 
           iits)
  end
